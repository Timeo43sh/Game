<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Hub - Mini Jeux</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #FF2D75;
            --secondary: #2B2B36;
            --dark: #1A1A23;
            --light: #F0F0F0;
            --accent: #00D1FF;
            --success: #4CAF50;
            --warning: #FFC107;
            --danger: #F44336;
            --card-bg: #242430;
            --text: #FFFFFF;
            --text-secondary: #B0B0B0;
            --golden: #FFD700;
            --prestige: #9C27B0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--dark);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--secondary);
        }

        .logo {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(to right, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .game-card {
            background: var(--card-bg);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .game-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
        }

        .game-card-image {
            height: 200px;
            background-size: cover;
            background-position: center;
            position: relative;
        }

        .game-card-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .game-card:hover .game-card-overlay {
            opacity: 1;
        }

        .play-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: transform 0.2s ease;
        }

        .play-button:hover {
            transform: scale(1.05);
        }

        .game-card-content {
            padding: 20px;
        }

        .game-card-title {
            font-size: 1.4rem;
            margin-bottom: 10px;
            color: var(--accent);
        }

        .game-card-description {
            color: var(--text-secondary);
            margin-bottom: 15px;
            font-size: 0.95rem;
        }

        .game-card-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .game-card-tag {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .tag-action {
            background: var(--primary);
            color: white;
        }

        .tag-puzzle {
            background: var(--accent);
            color: var(--dark);
        }

        .tag-idle {
            background: var(--warning);
            color: var(--dark);
        }

        .game-view {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--dark);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--secondary);
        }

        .game-title {
            font-size: 1.8rem;
            color: var(--accent);
        }

        .back-button {
            background: var(--secondary);
            color: var(--text);
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .game-container {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        /* Styles spécifiques pour Click Color */
        #click-color-game {
            text-align: center;
        }

        #color-display {
            width: 250px;
            height: 250px;
            margin: 0 auto 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: transform 0.2s;
        }

        #color-display:active {
            transform: scale(0.98);
        }

        #color-value {
            font-size: 1.2rem;
            margin-bottom: 15px;
            font-family: monospace;
            background: var(--secondary);
            padding: 5px 10px;
            border-radius: 5px;
            display: inline-block;
        }

        #click-counter {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--accent);
        }

        .color-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: var(--secondary);
            padding: 10px 15px;
            border-radius: 8px;
            min-width: 100px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .color-controls {
            margin-top: 20px;
        }

        .color-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 0 5px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .color-button:hover {
            background: #ff1a6b;
        }

        /* Styles pour Tetris */
        #tetris-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        #tetris-board {
            border: 3px solid var(--secondary);
            background: var(--dark);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
        }

        #tetris-side-panel {
            display: flex;
            flex-direction: column;
            gap: 25px;
            width: 200px;
        }

        .tetris-panel {
            background: var(--secondary);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tetris-panel-title {
            font-size: 1.3rem;
            color: var(--accent);
            margin-bottom: 15px;
            text-align: center;
            font-weight: 600;
        }

        #next-piece-container {
            width: 160px;
            height: 160px;
            margin: 0 auto;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        #next-piece {
            position: relative;
            width: 120px;
            height: 120px;
        }

        #tetris-score-display {
            font-size: 2rem;
            text-align: center;
            margin: 15px 0;
            color: var(--light);
            font-weight: 700;
        }

        #tetris-level-display {
            font-size: 1.2rem;
            text-align: center;
            color: var(--accent);
        }

        .tetris-btn {
            background: var(--primary);
            border: none;
            color: white;
            padding: 12px 24px;
            font-size: 1.1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            width: 100%;
            margin-top: 10px;
        }

        .tetris-btn:hover {
            background: #ff1a6b;
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(255, 45, 117, 0.3);
        }

        .tetris-btn:active {
            transform: translateY(0);
        }

        #tetris-start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 35, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            border-radius: 8px;
        }

        #tetris-game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 35, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 15;
            border-radius: 8px;
        }

        .tetris-screen-title {
            color: var(--primary);
            font-size: 3.5rem;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(255, 45, 117, 0.5);
            font-weight: 800;
        }

        .tetris-screen-subtitle {
            color: var(--accent);
            font-size: 1.5rem;
            margin-bottom: 40px;
        }

        .tetris-controls-list {
            list-style: none;
            margin-bottom: 30px;
        }

        .tetris-controls-list li {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .tetris-key {
            display: inline-block;
            background: var(--secondary);
            padding: 5px 10px;
            border-radius: 4px;
            margin-right: 10px;
            min-width: 30px;
            text-align: center;
            font-weight: 600;
        }

        /* Couleurs des pièces Tetris */
        .piece-I { background-color: #00F0FF; }
        .piece-J { background-color: #0000FF; }
        .piece-L { background-color: #FF8000; }
        .piece-O { background-color: #FFFF00; }
        .piece-S { background-color: #00FF00; }
        .piece-T { background-color: #8000FF; }
        .piece-Z { background-color: #FF0000; }

        /* Styles pour Banana Clicker */
        #banana-clicker-game {
            text-align: center;
        }

        #banana {
            width: 220px;
            height: 220px;
            cursor: pointer;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path fill="%23FFC107" d="M85 25c-5-15-25-15-30 0-5-15-25-15-30 0-5 15 0 35 15 50 15 15 35 20 50 15 15-5 20-25 15-40-5-15-15-20-20-25z"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            transition: transform 0.1s;
            filter: drop-shadow(0 10px 20px rgba(255,160,0,0.4));
            margin: 0 auto 20px;
        }

        #banana:active {
            transform: scale(0.92);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        .click-effect {
            position: absolute;
            font-size: 1.8rem;
            animation: floatAway 1.5s forwards;
            z-index: 100;
            pointer-events: none;
            font-weight: 700;
            text-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .click-effect.special {
            animation: floatAway 1.5s forwards, pulse 0.5s infinite alternate;
            z-index: 101;
            font-size: 2.2rem;
            font-weight: 900;
            text-shadow: 0 0 10px gold;
        }

        @keyframes floatAway {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-100px) rotate(20deg); opacity: 0; }
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }

        #banana-counter {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: var(--warning);
        }

        #banana-bps {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .banana-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .banana-upgrades {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .banana-upgrade {
            background: var(--secondary);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--warning);
        }

        .banana-upgrade-title {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: var(--accent);
        }

        .banana-upgrade-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .banana-upgrade-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .banana-upgrade-cost {
            color: var(--primary);
            font-weight: 600;
        }

        .banana-upgrade-owned {
            color: var(--success);
        }

        .banana-btn {
            background: var(--warning);
            color: var(--dark);
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: 600;
            width: 100%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .banana-btn:hover {
            transform: translateY(-2px);
        }

        .banana-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .banana-tab-buttons {
            display: flex;
            border-bottom: 2px solid var(--secondary);
            margin-bottom: 20px;
        }

        .banana-tab-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            position: relative;
        }

        .banana-tab-btn.active {
            color: var(--accent);
        }

        .banana-tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--accent);
        }

        .banana-tab-content {
            display: none;
        }

        .banana-tab-content.active {
            display: block;
        }

        .prestige-section {
            background: rgba(156, 39, 176, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border: 1px solid var(--prestige);
        }

        .prestige-btn {
            background: var(--prestige);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }

        .prestige-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .prestige-info {
            margin-bottom: 15px;
        }

        .golden-banana {
            color: var(--golden);
            font-weight: 600;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .game-grid {
                grid-template-columns: 1fr;
            }
            
            .game-card-image {
                height: 150px;
            }
            
            #color-display {
                width: 200px;
                height: 200px;
            }
            
            #tetris-container {
                flex-direction: column;
                align-items: center;
            }
            
            #tetris-side-panel {
                width: 100%;
                max-width: 300px;
            }
        }

        /* Styles pour les nouvelles fonctionnalités du Banana Clicker */
        .banana-events {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .banana-event {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
            animation: pulse 2s infinite alternate;
        }

        .event-icon {
            font-size: 1.5rem;
            margin-right: 15px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
        }

        .event-info {
            flex: 1;
        }

        .event-info h4 {
            margin: 0 0 5px;
            font-size: 1.1rem;
        }

        .event-info p {
            margin: 0 0 5px;
            font-size: 0.9rem;
        }

        .event-timer {
            font-weight: 600;
            font-size: 0.85rem;
            background: rgba(0, 0, 0, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
            display: inline-block;
        }

        .achievement-notification, .game-notification {
            position: fixed;
            right: -400px;
            bottom: 20px;
            background: var(--secondary);
            border-left: 4px solid var(--primary);
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            padding: 15px;
            width: 320px;
            z-index: 1000;
            transition: transform 0.4s ease, opacity 0.4s ease;
            opacity: 0;
        }

        .achievement-notification {
            display: flex;
            align-items: center;
        }

        .game-notification {
            padding: 15px 20px;
            background: var(--accent);
            color: var(--dark);
            text-align: center;
            font-weight: 600;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
        }

        .achievement-icon {
            font-size: 2rem;
            margin-right: 15px;
            color: var(--accent);
            width: 40px;
            text-align: center;
        }

        .achievement-info h4 {
            margin: 0 0 5px;
            color: var(--primary);
        }

        .achievement-info p {
            margin: 0 0 5px;
            font-size: 0.9rem;
        }

        .achievement-reward {
            color: var(--accent);
            font-weight: 600;
        }

        .banana-achievements {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .banana-achievement {
            background: var(--secondary);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .banana-achievement.locked {
            opacity: 0.6;
            filter: grayscale(0.8);
        }

        .banana-achievement.unlocked {
            border-left: 4px solid var(--accent);
        }

        .achievement-date {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .achievement-counter {
            background: var(--secondary);
            padding: 10px 15px;
            border-radius: 5px;
            text-align: center;
            margin: 10px 0;
            font-weight: 600;
            color: var(--accent);
        }

        .banana-stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: var(--secondary);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .banana-btn.can-afford {
            background: var(--primary);
            color: white;
        }

        @keyframes pulse {
            0% { opacity: 0.85; }
            100% { opacity: 1; }
        }

        /* Effet de pulsation sur la banane */
        #banana {
            animation: float 4s infinite ease-in-out;
        }

        /* Animation améliorée pour les clics */
        .click-effect {
            animation: floatAway 1.5s forwards, rotate 2s infinite;
        }

        @keyframes rotate {
            0% { transform: translateY(0) rotate(0deg); }
            100% { transform: translateY(-100px) rotate(20deg); }
        }

        /* Responsive design pour mobiles */
        @media (max-width: 768px) {
            .banana-events {
                margin: 10px 0;
            }
            
            .banana-event {
                padding: 8px 10px;
            }
            
            .event-icon {
                font-size: 1.2rem;
                margin-right: 10px;
                width: 30px;
                height: 30px;
            }
            
            .achievement-notification {
                width: 280px;
                right: -280px;
            }
            
            .banana-achievements {
                grid-template-columns: 1fr;
            }
            
            .banana-stats-container {
                grid-template-columns: 1fr;
            }
        }

        /* Styles pour le jeu de test de réaction */
        #reaction-test-game {
            text-align: center;
            max-width: 600px;
            margin: 0 auto;
        }

        #reaction-box {
            width: 300px;
            height: 300px;
            background-color: #2B2B36;
            margin: 30px auto;
            border-radius: 15px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 600;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            transition: background-color 0.1s;
        }

        #reaction-box.waiting {
            background-color: #F44336;
        }

        #reaction-box.ready {
            background-color: #4CAF50;
        }

        #reaction-box.too-soon {
            background-color: #FFC107;
        }

        #reaction-times {
            display: flex;
            justify-content: space-around;
            max-width: 500px;
            margin: 30px auto;
            gap: 15px;
        }

        .reaction-time-box {
            background: var(--secondary);
            padding: 15px;
            border-radius: 10px;
            min-width: 120px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .reaction-time-label {
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .reaction-time-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
        }

        #reaction-message {
            font-size: 1.2rem;
            margin: 20px 0;
            min-height: 30px;
            color: var(--text);
        }

        .reaction-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s;
        }

        .reaction-btn:hover {
            background: #ff1a6b;
            transform: translateY(-2px);
        }

        /* Styles pour le jeu de Blackjack */
        #blackjack-game {
            max-width: 800px;
            margin: 0 auto;
        }

        .blackjack-table {
            background: #0a7e07;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            margin: 20px auto;
            position: relative;
        }

        .blackjack-hand {
            min-height: 150px;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }

        .blackjack-hand-title {
            font-size: 1.2rem;
            color: white;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .blackjack-score {
            background: var(--dark);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: 600;
        }

        .blackjack-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .blackjack-card {
            width: 100px;
            height: 140px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px;
            font-weight: 600;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.5s;
        }

        .blackjack-card.hidden {
            background: linear-gradient(135deg, #FF416C, #FF4B2B);
        }

        .card-value {
            font-size: 1.5rem;
        }

        .card-suit {
            font-size: 2rem;
            text-align: center;
        }

        .card-suit.red {
            color: #E53935;
        }

        .card-suit.black {
            color: #212121;
        }

        .blackjack-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .blackjack-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .blackjack-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .blackjack-btn:disabled {
            background: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .blackjack-btn.hit {
            background: var(--accent);
        }

        .blackjack-btn.stand {
            background: var(--danger);
        }

        .blackjack-btn.double {
            background: var(--golden);
            color: var(--dark);
        }

        .blackjack-info {
            margin: 20px 0;
            text-align: center;
        }

        .blackjack-message {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .blackjack-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .blackjack-stat {
            background: var(--secondary);
            padding: 15px;
            border-radius: 10px;
            min-width: 120px;
            text-align: center;
        }

        .blackjack-stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .blackjack-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .blackjack-bet-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
        }

        .blackjack-bet-input {
            background: var(--secondary);
            border: 2px solid var(--primary);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 1.2rem;
            width: 100px;
            text-align: center;
        }

        .chip {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
            color: white;
            border: 3px dashed rgba(255, 255, 255, 0.5);
        }

        .chip:hover {
            transform: scale(1.1);
        }

        .chip.red {
            background: #E53935;
        }

        .chip.blue {
            background: #1E88E5;
        }

        .chip.green {
            background: #43A047;
        }

        .chip.black {
            background: #212121;
        }

        .blackjack-result {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            z-index: 10;
            transform: scale(0);
            transition: transform 0.3s ease;
        }

        .blackjack-result.visible {
            transform: scale(1);
        }

        .result-title {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 20px;
        }

        .result-win {
            color: #4CAF50;
        }

        .result-lose {
            color: #F44336;
        }

        .result-push {
            color: #FFC107;
        }

        .result-blackjack {
            color: #9C27B0;
        }

        .result-amount {
            font-size: 2rem;
            margin-bottom: 30px;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00;
            border-radius: 50%;
            animation: confetti-fall 4s linear forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(600px) rotate(360deg);
                opacity: 0;
            }
        }

        /* Styles pour le jeu Sweet Match (style Candy Crush) */
        #sweet-match-game {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }

        .sweet-match-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 4px;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1;
            margin: 20px auto;
            background-color: var(--secondary);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }

        .sweet-cell {
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .sweet-cell.selected {
            transform: scale(0.9);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        .sweet-cell.swapping {
            z-index: 10;
        }

        .sweet-cell.matched {
            opacity: 0.4;
            transform: scale(0.8);
        }

        .sweet-candy {
            width: 90%;
            height: 90%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: white;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .sweet-candy-red {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }

        .sweet-candy-blue {
            background: linear-gradient(135deg, #2196f3, #1976d2);
        }

        .sweet-candy-green {
            background: linear-gradient(135deg, #4caf50, #388e3c);
        }

        .sweet-candy-yellow {
            background: linear-gradient(135deg, #ffeb3b, #fbc02d);
        }

        .sweet-candy-purple {
            background: linear-gradient(135deg, #9c27b0, #7b1fa2);
        }

        .sweet-candy-orange {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .sweet-match-info {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .sweet-stat {
            background: var(--secondary);
            padding: 15px;
            border-radius: 10px;
            min-width: 120px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .sweet-stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .sweet-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .sweet-match-controls {
            margin: 20px 0;
        }

        .sweet-match-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.2s;
        }

        .sweet-match-btn:hover {
            background: #ff1a6b;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 45, 117, 0.3);
        }

        #sweet-match-message {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 20px 0;
            min-height: 30px;
            color: var(--text);
        }

        .sweet-explosion {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            animation: sweet-explode 0.5s forwards;
        }

        @keyframes sweet-explode {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .sweet-match-progress {
            width: 100%;
            max-width: 500px;
            height: 20px;
            background-color: var(--secondary);
            border-radius: 10px;
            margin: 10px auto;
            overflow: hidden;
        }

        .sweet-match-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .sweet-level-info {
            font-size: 1.2rem;
            margin: 10px 0;
        }

        .sweet-time-bar {
            width: 100%;
            max-width: 500px;
            height: 10px;
            background-color: var(--secondary);
            border-radius: 5px;
            margin: 10px auto;
            overflow: hidden;
        }

        .sweet-time-progress {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 100%;
            transition: width 0.1s linear;
        }

        /* Styles pour le jeu de Pong */
        #pong-game {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }

        .pong-canvas-container {
            width: 100%;
            max-width: 600px;
            height: 400px;
            margin: 20px auto;
            background-color: var(--dark);
            border: 3px solid var(--secondary);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        #pong-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .pong-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .pong-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pong-btn:hover {
            background: #ff1a6b;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 45, 117, 0.3);
        }

        .pong-btn:active {
            transform: translateY(0);
        }

        .pong-score-display {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 20px 0;
        }

        .pong-score-box {
            background: var(--secondary);
            padding: 15px 30px;
            border-radius: 10px;
            min-width: 100px;
            text-align: center;
        }

        .pong-score-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .pong-score-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent);
        }

        .pong-message {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 20px 0;
            min-height: 30px;
            color: var(--text);
        }

        .pong-info {
            max-width: 500px;
            margin: 20px auto;
            background: var(--secondary);
            padding: 15px;
            border-radius: 10px;
        }

        .pong-info h3 {
            color: var(--accent);
            margin-bottom: 10px;
        }

        .pong-info p {
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .pong-info ul {
            text-align: left;
            color: var(--text-secondary);
            margin: 10px 0 10px 20px;
        }

        .pong-difficulty {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .pong-difficulty label {
            color: var(--text-secondary);
            margin-right: 10px;
        }

        .pong-difficulty select {
            background: var(--secondary);
            color: var(--text);
            border: 1px solid var(--accent);
            padding: 8px 12px;
            border-radius: 5px;
        }

        .pong-paddle {
            position: absolute;
            width: 10px;
            height: 80px;
            background-color: white;
            border-radius: 5px;
        }

        .pong-paddle.left {
            left: 20px;
        }

        .pong-paddle.right {
            right: 20px;
        }

        .pong-ball {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: white;
            border-radius: 50%;
        }

        .pong-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            color: white;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">Arcade Hub</div>
            <div class="tagline">Collection de mini-jeux</div>
        </header>
        
        <div class="game-grid">
            <!-- Carte Click Color -->
            <div class="game-card" onclick="openGame('click-color')">
                <div class="game-card-image" style="background-color: #FF5733;">
                    <div class="game-card-overlay">
                        <button class="play-button">
                            <i class="fas fa-play"></i> Jouer
                        </button>
                    </div>
                </div>
                <div class="game-card-content">
                    <h3 class="game-card-title">Click Color</h3>
                    <p class="game-card-description">Cliquez sur la couleur affichée pour marquer des points. Simple mais addictif!</p>
                    <div>
                        <span class="game-card-tag tag-action">Action</span>
                        <span class="game-card-tag tag-puzzle">Réflexe</span>
                    </div>
                </div>
            </div>
            
            <!-- Carte Tetris -->
            <div class="game-card" onclick="openGame('tetris')">
                <div class="game-card-image" style="background: linear-gradient(135deg, #00D1FF, #8000FF);">
                    <div class="game-card-overlay">
                        <button class="play-button">
                            <i class="fas fa-play"></i> Jouer
                        </button>
                    </div>
                </div>
                <div class="game-card-content">
                    <h3 class="game-card-title">Tetris</h3>
                    <p class="game-card-description">Le jeu de puzzle classique avec des graphismes modernes. Faites des lignes pour marquer des points!</p>
                    <div>
                        <span class="game-card-tag tag-puzzle">Puzzle</span>
                        <span class="game-card-tag tag-action">Classique</span>
                    </div>
                </div>
            </div>

            <!-- Carte Banana Clicker -->
            <div class="game-card" onclick="openGame('banana-clicker')">
                <div class="game-card-image" style="background: linear-gradient(135deg, #FFC107, #FF5722);">
                    <div class="game-card-overlay">
                        <button class="play-button">
                            <i class="fas fa-play"></i> Jouer
                        </button>
                    </div>
                </div>
                <div class="game-card-content">
                    <h3 class="game-card-title">Banana Clicker</h3>
                    <p class="game-card-description">Cliquez pour collecter des bananes, débloquez des améliorations et construisez votre empire bananier!</p>
                    <div>
                        <span class="game-card-tag tag-idle">Incremental</span>
                        <span class="game-card-tag tag-action">Clicker</span>
                    </div>
                </div>
            </div>
            
            <!-- Carte Test de Réaction -->
            <div class="game-card" onclick="openGame('reaction-test')">
                <div class="game-card-image" style="background: linear-gradient(135deg, #4CAF50, #2196F3);">
                    <div class="game-card-overlay">
                        <button class="play-button">
                            <i class="fas fa-play"></i> Jouer
                        </button>
                    </div>
                </div>
                <div class="game-card-content">
                    <h3 class="game-card-title">Test de Réaction</h3>
                    <p class="game-card-description">Testez vos réflexes! Cliquez dès que la couleur change et découvrez votre temps de réaction.</p>
                    <div>
                        <span class="game-card-tag tag-action">Réflexe</span>
                        <span class="game-card-tag tag-puzzle">Vitesse</span>
                    </div>
                </div>
            </div>
            
            <!-- Carte Blackjack -->
            <div class="game-card" onclick="openGame('blackjack')">
                <div class="game-card-image" style="background: linear-gradient(135deg, #0a7e07, #000000);">
                    <div class="game-card-overlay">
                        <button class="play-button">
                            <i class="fas fa-play"></i> Jouer
                        </button>
                    </div>
                </div>
                <div class="game-card-content">
                    <h3 class="game-card-title">Blackjack</h3>
                    <p class="game-card-description">Le célèbre jeu de cartes de casino. Battez le croupier en obtenant un score proche de 21 sans le dépasser!</p>
                    <div>
                        <span class="game-card-tag tag-puzzle">Cartes</span>
                        <span class="game-card-tag tag-action">Casino</span>
                    </div>
                </div>
            </div>
            
            <!-- Carte Sweet Match -->
            <div class="game-card" onclick="openGame('sweet-match')">
                <div class="game-card-image" style="background: linear-gradient(135deg, #f44336, #9c27b0, #4caf50, #ffeb3b);">
                    <div class="game-card-overlay">
                        <button class="play-button">
                            <i class="fas fa-play"></i> Jouer
                        </button>
                    </div>
                </div>
                <div class="game-card-content">
                    <h3 class="game-card-title">Sweet Match</h3>
                    <p class="game-card-description">Alignez des bonbons colorés pour faire des combinaisons et marquer des points dans ce jeu inspiré de Candy Crush!</p>
                    <div>
                        <span class="game-card-tag tag-puzzle">Match-3</span>
                        <span class="game-card-tag tag-action">Puzzle</span>
                    </div>
                </div>
            </div>
            
            <!-- Carte Pong -->
            <div class="game-card" onclick="openGame('pong')">
                <div class="game-card-image" style="background: linear-gradient(135deg, #000000, #333333);">
                    <div class="game-card-overlay">
                        <button class="play-button">
                            <i class="fas fa-play"></i> Jouer
                        </button>
                    </div>
                </div>
                <div class="game-card-content">
                    <h3 class="game-card-title">Pong</h3>
                    <p class="game-card-description">Le classique jeu de tennis de table arcade! Contrôlez la raquette et évitez que la balle ne dépasse votre côté.</p>
                    <div>
                        <span class="game-card-tag tag-action">Arcade</span>
                        <span class="game-card-tag tag-puzzle">Classique</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Vue Click Color -->
        <div id="click-color-view" class="game-view">
            <div class="game-header">
                <h2 class="game-title">Click Color</h2>
                <button class="back-button" onclick="closeGame()">
                    <i class="fas fa-arrow-left"></i> Retour
                </button>
            </div>
            
            <div class="game-container" id="click-color-game">
                <div id="click-counter">0</div>
                <div id="color-display"></div>
                <div id="color-value">#FFFFFF</div>
                
                <div class="color-stats">
                    <div class="stat-box">
                        <div class="stat-label">Meilleur score</div>
                        <div class="stat-value" id="best-score">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Taux de réussite</div>
                        <div class="stat-value" id="success-rate">0%</div>
                    </div>
                </div>
                
                <div class="color-controls">
                    <button class="color-button" onclick="resetClickColor()">
                        <i class="fas fa-redo"></i> Réinitialiser
                    </button>
                    <button class="color-button" onclick="changeColorMode('hex')">
                        <i class="fas fa-hashtag"></i> Mode HEX
                    </button>
                    <button class="color-button" onclick="changeColorMode('rgb')">
                        <i class="fas fa-palette"></i> Mode RGB
                    </button>
                </div>
                    </div>
                </div>
                
        <!-- Vue Tetris -->
        <div id="tetris-view" class="game-view">
            <div class="game-header">
                <h2 class="game-title">Tetris</h2>
                <button class="back-button" onclick="closeGame()">
                    <i class="fas fa-arrow-left"></i> Retour
                </button>
                </div>
                
            <div class="game-container">
                <div id="tetris-container">
                    <div id="tetris-main-game" style="position: relative;">
                        <canvas id="tetris-board" width="300" height="600"></canvas>
                        
                        <div id="tetris-start-screen">
                            <h1 class="tetris-screen-title">TETRIS</h1>
                            <p class="tetris-screen-subtitle">Un jeu classique réinventé</p>
                            <button id="tetris-start-btn" class="tetris-btn">COMMENCER</button>
                            
                            <ul class="tetris-controls-list">
                                <li><span class="tetris-key">← →</span> Déplacer</li>
                                <li><span class="tetris-key">↑</span> Tourner</li>
                                <li><span class="tetris-key">↓</span> Descendre</li>
                                <li><span class="tetris-key">Espace</span> Tomber</li>
                                <li><span class="tetris-key">P</span> Pause</li>
                            </ul>
                </div>
                
                        <div id="tetris-game-over">
                            <h1 class="tetris-screen-title">GAME OVER</h1>
                            <div class="tetris-screen-subtitle" id="tetris-final-score">Score: 0</div>
                            <button id="tetris-restart-btn" class="tetris-btn">REJOUER</button>
                    </div>
                </div>
                    
                    <div id="tetris-side-panel">
                        <div class="tetris-panel">
                            <h2 class="tetris-panel-title">Prochaine pièce</h2>
                            <div id="next-piece-container">
                                <div id="next-piece"></div>
            </div>
        </div>

                        <div class="tetris-panel">
                            <h2 class="tetris-panel-title">Score</h2>
                            <div id="tetris-score-display">0</div>
                            <div id="tetris-level-display">Niveau: 1</div>
                        </div>
                        
                        <div class="tetris-panel">
                            <h2 class="tetris-panel-title">Contrôles</h2>
                            <button id="tetris-pause-btn" class="tetris-btn">PAUSE</button>
                            <button id="tetris-new-game-btn" class="tetris-btn">NOUVELLE PARTIE</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Vue Banana Clicker -->
        <div id="banana-clicker-view" class="game-view">
            <div class="game-header">
                <h2 class="game-title">Banana Clicker</h2>
                <button class="back-button" onclick="closeGame()">
                    <i class="fas fa-arrow-left"></i> Retour
                    </button>
                </div>
            
            <div class="game-container" id="banana-clicker-game">
                <div id="banana-counter">0 bananes</div>
                <div id="banana-bps">0 bananes/seconde</div>
                <div id="banana-container">
                    <div id="banana" title="Cliquez pour gagner des bananes!"></div>
            </div>
                
                <div class="banana-stats">
                    <div class="stat-box">
                        <div class="stat-label">Total clics</div>
                        <div class="stat-value" id="banana-total-clicks">0</div>
                </div>
                    <div class="stat-box">
                        <div class="stat-label">Multiplicateur</div>
                        <div class="stat-value" id="banana-multiplier">1x</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Bananes dorées</div>
                        <div class="stat-value golden-banana" id="banana-golden">0</div>
            </div>
        </div>

                <div class="banana-tab-buttons">
                    <button class="banana-tab-btn active" onclick="openBananaTab('upgrades')">Améliorations</button>
                    <button class="banana-tab-btn" onclick="openBananaTab('prestige')">Prestige</button>
                </div>
                
                <div id="banana-upgrades-tab" class="banana-tab-content active">
                    <h3>Améliorations de production</h3>
                    <div class="banana-upgrades" id="banana-upgrades-container">
                        <!-- Les améliorations seront ajoutées dynamiquement -->
                    </div>
                    
                    <h3 style="margin-top: 20px;">Améliorations spéciales</h3>
                    <div class="banana-upgrades" id="banana-special-upgrades-container">
                        <!-- Les améliorations spéciales seront ajoutées dynamiquement -->
                    </div>
                </div>
                
                <div id="banana-prestige-tab" class="banana-tab-content">
                    <div class="prestige-section">
                        <h3>Système de Prestige</h3>
                        <p class="prestige-info">
                            Effectuez un prestige pour réinitialiser votre progression et gagner des <span class="golden-banana">Bananes Dorées</span> qui donnent des bonus permanents!
                        </p>
                        <p id="prestige-requirement">Vous avez besoin d'au moins 1,000,000 bananes pour effectuer un prestige.</p>
                        <p id="prestige-reward">Vous obtiendrez 0 Bananes Dorées</p>
                        <button class="prestige-btn" id="prestige-btn" disabled>PRESTIGE</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <audio id="clickSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3"></audio>
    <audio id="upgradeSound" src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3"></audio>
    <audio id="specialSound" src="https://assets.mixkit.co/sfx/preview/mixkit-extra-bonus-in-a-video-game-2045.mp3"></audio>
    <audio id="prestigeSound" src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3"></audio>
    
    <!-- Vue Test de Réaction -->
    <div id="reaction-test-view" class="game-view">
        <div class="game-header">
            <h2 class="game-title">Test de Réaction</h2>
            <button class="back-button" onclick="closeGame()">
                <i class="fas fa-arrow-left"></i> Retour
            </button>
        </div>
        
        <div class="game-container" id="reaction-test-game">
            <div id="reaction-message">Cliquez sur le carré quand il devient VERT</div>
            
            <div id="reaction-box">Cliquez pour commencer</div>
            
            <div id="reaction-times">
                <div class="reaction-time-box">
                    <div class="reaction-time-label">Dernier temps</div>
                    <div class="reaction-time-value" id="last-time">0 ms</div>
                </div>
                <div class="reaction-time-box">
                    <div class="reaction-time-label">Meilleur temps</div>
                    <div class="reaction-time-value" id="best-time">0 ms</div>
                </div>
                <div class="reaction-time-box">
                    <div class="reaction-time-label">Moyenne</div>
                    <div class="reaction-time-value" id="average-time">0 ms</div>
                </div>
            </div>
            
            <button class="reaction-btn" id="reset-reaction-btn">
                <i class="fas fa-redo"></i> Réinitialiser
            </button>
        </div>
    </div>

    <!-- Vue Blackjack -->
    <div id="blackjack-view" class="game-view">
        <div class="game-header">
            <h2 class="game-title">Blackjack</h2>
            <button class="back-button" onclick="closeGame()">
                <i class="fas fa-arrow-left"></i> Retour
            </button>
        </div>
        
        <div class="game-container" id="blackjack-game">
            <div class="blackjack-stats">
                <div class="blackjack-stat">
                    <div class="blackjack-stat-label">Solde</div>
                    <div class="blackjack-stat-value" id="blackjack-balance">10000€</div>
                </div>
                <div class="blackjack-stat">
                    <div class="blackjack-stat-label">Mise actuelle</div>
                    <div class="blackjack-stat-value" id="blackjack-current-bet">0€</div>
                </div>
                <div class="blackjack-stat">
                    <div class="blackjack-stat-label">Parties jouées</div>
                    <div class="blackjack-stat-value" id="blackjack-games-played">0</div>
                </div>
                <div class="blackjack-stat">
                    <div class="blackjack-stat-label">Parties gagnées</div>
                    <div class="blackjack-stat-value" id="blackjack-games-won">0</div>
                </div>
            </div>
            
            <div class="blackjack-bet-container" id="bet-container">
                <div class="chip red" onclick="addToBet(5)">5€</div>
                <div class="chip blue" onclick="addToBet(10)">10€</div>
                <div class="chip green" onclick="addToBet(25)">25€</div>
                <div class="chip black" onclick="addToBet(100)">100€</div>
                <input type="number" id="blackjack-bet" class="blackjack-bet-input" min="5" max="1000" step="5" value="10">
                <button class="blackjack-btn" id="place-bet-btn" onclick="startBlackjackGame()">
                    <i class="fas fa-check"></i> Miser
                </button>
                <button class="blackjack-btn" id="clear-bet-btn" onclick="clearBet()">
                    <i class="fas fa-times"></i> Effacer
                </button>
            </div>
            
            <div class="blackjack-table" id="blackjack-table" style="display: none;">
                <div class="blackjack-hand">
                    <div class="blackjack-hand-title">
                        Main du croupier <span class="blackjack-score" id="dealer-score">0</span>
                    </div>
                    <div class="blackjack-cards" id="dealer-cards"></div>
                </div>
                
                <div class="blackjack-hand">
                    <div class="blackjack-hand-title">
                        Votre main <span class="blackjack-score" id="player-score">0</span>
                    </div>
                    <div class="blackjack-cards" id="player-cards"></div>
                </div>
                
                <div class="blackjack-actions" id="blackjack-actions">
                    <button class="blackjack-btn hit" id="hit-btn">
                        <i class="fas fa-plus"></i> Carte
                    </button>
                    <button class="blackjack-btn stand" id="stand-btn">
                        <i class="fas fa-hand"></i> Rester
                    </button>
                    <button class="blackjack-btn double" id="double-btn">
                        <i class="fas fa-coins"></i> Doubler
                    </button>
                </div>
                
                <div class="blackjack-result" id="blackjack-result">
                    <div class="result-title" id="result-title">VICTOIRE!</div>
                    <div class="result-amount" id="result-amount">+100€</div>
                    <button class="blackjack-btn" id="play-again-btn">
                        <i class="fas fa-redo"></i> Rejouer
                    </button>
                </div>
            </div>
            
            <div class="blackjack-info">
                <div class="blackjack-message" id="blackjack-message">Placez votre mise pour commencer</div>
            </div>
        </div>
    </div>
    
    <!-- Vue Sweet Match -->
    <div id="sweet-match-view" class="game-view">
        <div class="game-header">
            <h2 class="game-title">Sweet Match</h2>
            <button class="back-button" onclick="closeGame()">
                <i class="fas fa-arrow-left"></i> Retour
            </button>
        </div>
        
        <div class="game-container" id="sweet-match-game">
            <div class="sweet-match-info">
                <div class="sweet-stat">
                    <div class="sweet-stat-label">Score</div>
                    <div class="sweet-stat-value" id="sweet-score">0</div>
                </div>
                <div class="sweet-stat">
                    <div class="sweet-stat-label">Meilleur score</div>
                    <div class="sweet-stat-value" id="sweet-best-score">0</div>
                </div>
                <div class="sweet-stat">
                    <div class="sweet-stat-label">Niveau</div>
                    <div class="sweet-stat-value" id="sweet-level">1</div>
                </div>
                <div class="sweet-stat">
                    <div class="sweet-stat-label">Mouvements</div>
                    <div class="sweet-stat-value" id="sweet-moves">15</div>
                </div>
            </div>
            
            <div class="sweet-level-info">Objectif du niveau: <span id="sweet-level-target">1000</span> points</div>
            
            <div class="sweet-match-progress">
                <div class="sweet-match-progress-bar" id="sweet-progress-bar"></div>
            </div>
            
            <div class="sweet-time-bar">
                <div class="sweet-time-progress" id="sweet-time-bar"></div>
            </div>
            
            <div id="sweet-match-message">Alignez 3 bonbons ou plus pour marquer des points!</div>
            
            <div class="sweet-match-board" id="sweet-match-board">
                <!-- La grille sera générée dynamiquement en JavaScript -->
            </div>
            
            <div class="sweet-match-controls">
                <button class="sweet-match-btn" id="sweet-new-game-btn">
                    <i class="fas fa-redo"></i> Nouvelle partie
                </button>
                <button class="sweet-match-btn" id="sweet-hint-btn">
                    <i class="fas fa-lightbulb"></i> Indice
                </button>
            </div>
        </div>
    </div>
    
    <!-- Vue Pong -->
    <div id="pong-view" class="game-view">
        <div class="game-header">
            <h2 class="game-title">Pong</h2>
            <button class="back-button" onclick="closeGame()">
                <i class="fas fa-arrow-left"></i> Retour
            </button>
        </div>
        
        <div class="game-container" id="pong-game">
            <div class="pong-score-display">
                <div class="pong-score-box">
                    <div class="pong-score-label">Vous</div>
                    <div class="pong-score-value" id="pong-player-score">0</div>
                </div>
                <div class="pong-score-box">
                    <div class="pong-score-label">IA</div>
                    <div class="pong-score-value" id="pong-ai-score">0</div>
                </div>
            </div>
            
            <div class="pong-message" id="pong-message">Utilisez les touches ↑/↓ ou la souris pour contrôler votre raquette</div>
            
            <div class="pong-canvas-container">
                <div id="pong-game-container">
                    <!-- Les éléments du jeu seront générés dynamiquement ici -->
                </div>
            </div>
            
            <div class="pong-difficulty">
                <label for="pong-difficulty-select">Difficulté:</label>
                <select id="pong-difficulty-select">
                    <option value="easy">Facile</option>
                    <option value="medium" selected>Moyen</option>
                    <option value="hard">Difficile</option>
                </select>
            </div>
            
            <div class="pong-controls">
                <button class="pong-btn" id="pong-start-btn">
                    <i class="fas fa-play"></i> Commencer
                </button>
                <button class="pong-btn" id="pong-reset-btn">
                    <i class="fas fa-redo"></i> Réinitialiser
                </button>
                <button class="pong-btn" id="pong-pause-btn">
                    <i class="fas fa-pause"></i> Pause
                </button>
            </div>
            
            <div class="pong-info">
                <h3>Instructions</h3>
                <p>Pong est un jeu de tennis de table simple où vous contrôlez la raquette de gauche.</p>
                <ul>
                    <li>Utilisez les touches flèches ↑/↓ pour déplacer votre raquette</li>
                    <li>Vous pouvez aussi utiliser la souris en déplaçant le curseur verticalement</li>
                    <li>Essayez de faire rebondir la balle et d'empêcher qu'elle ne dépasse votre côté</li>
                    <li>Marquez des points quand l'IA manque la balle</li>
                    <li>Premier à 10 points gagne la partie</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Gestion des vues de jeu
        function openGame(gameId) {
            document.querySelectorAll('.game-view').forEach(view => {
                view.style.display = 'none';
            });
            document.getElementById(`${gameId}-view`).style.display = 'block';
            
            // Initialiser le jeu si ce n'est pas déjà fait
            if (gameId === 'click-color' && !window.clickColorInitialized) {
                initClickColor();
                window.clickColorInitialized = true;
            } else if (gameId === 'tetris' && !window.tetrisInitialized) {
                initTetris();
                window.tetrisInitialized = true;
            } else if (gameId === 'banana-clicker' && !window.bananaClickerInitialized) {
                initBananaClicker();
                window.bananaClickerInitialized = true;
            } else if (gameId === 'reaction-test' && !window.reactionTestInitialized) {
                initReactionTest();
                window.reactionTestInitialized = true;
            } else if (gameId === 'blackjack' && !window.blackjackInitialized) {
                initBlackjack();
                window.blackjackInitialized = true;
            } else if (gameId === 'sweet-match' && !window.sweetMatchInitialized) {
                initSweetMatch();
                window.sweetMatchInitialized = true;
            } else if (gameId === 'pong' && !window.pongInitialized) {
                initPong();
                window.pongInitialized = true;
            }
        }

        function closeGame() {
            document.querySelectorAll('.game-view').forEach(view => {
                view.style.display = 'none';
            });
        }

        function openBananaTab(tabId) {
            document.querySelectorAll('#banana-clicker-game .banana-tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('#banana-clicker-game .banana-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            document.querySelector(`#banana-clicker-game .banana-tab-btn[onclick="openBananaTab('${tabId}')"]`).classList.add('active');
            document.getElementById(`banana-${tabId}-tab`).classList.add('active');
        }

        // Jeu Click Color
        function initClickColor() {
            const colorDisplay = document.getElementById('color-display');
            const colorValue = document.getElementById('color-value');
            const clickCounter = document.getElementById('click-counter');
            const bestScore = document.getElementById('best-score');
            const successRate = document.getElementById('success-rate');
            
            let score = 0;
            let best = localStorage.getItem('clickColorBestScore') || 0;
            let totalClicks = 0;
            let successfulClicks = 0;
            let colorMode = 'hex'; // 'hex' ou 'rgb'
            
            bestScore.textContent = best;
            
            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }
            
            function getRandomRGB() {
                const r = Math.floor(Math.random() * 256);
                const g = Math.floor(Math.random() * 256);
                const b = Math.floor(Math.random() * 256);
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            function updateColor() {
                if (colorMode === 'hex') {
                    const color = getRandomColor();
                    colorDisplay.style.backgroundColor = color;
                    colorValue.textContent = color;
                } else {
                    const color = getRandomRGB();
                    colorDisplay.style.backgroundColor = color;
                    colorValue.textContent = color;
                }
            }
            
            function handleClick() {
                totalClicks++;
                const currentColor = colorDisplay.style.backgroundColor;
                const displayedValue = colorValue.textContent;
                
                let isCorrect = false;
                
                if (colorMode === 'hex') {
                    // Convertir la couleur RGB affichée en HEX pour comparaison
                    const rgbToHex = (rgb) => {
                        const values = rgb.match(/\d+/g);
                        const hex = values.map(v => {
                            const val = parseInt(v);
                            return val.toString(16).padStart(2, '0');
                        });
                        return `#${hex.join('').toUpperCase()}`;
                    };
                    
                    const actualHex = rgbToHex(currentColor);
                    isCorrect = actualHex === displayedValue;
                } else {
                    // En mode RGB, on compare directement
                    isCorrect = currentColor === displayedValue;
                }
                
                if (isCorrect) {
                    score++;
                    successfulClicks++;
                    clickCounter.textContent = score;
                    colorDisplay.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        colorDisplay.style.transform = 'scale(1)';
                    }, 100);
                    
                    if (score > best) {
                        best = score;
                        bestScore.textContent = best;
                        localStorage.setItem('clickColorBestScore', best);
                    }
                } else {
                    score = 0;
                    clickCounter.textContent = score;
                }
                
                // Mettre à jour le taux de réussite
                const rate = Math.round((successfulClicks / totalClicks) * 100);
                successRate.textContent = `${rate}%`;
                
                updateColor();
            }
            
            function resetGame() {
                score = 0;
                totalClicks = 0;
                successfulClicks = 0;
                clickCounter.textContent = score;
                successRate.textContent = '0%';
                updateColor();
            }
            
            function changeMode(mode) {
                colorMode = mode;
                resetGame();
            }
            
            // Événements
            colorDisplay.addEventListener('click', handleClick);
            window.resetClickColor = resetGame;
            window.changeColorMode = changeMode;
            
            // Démarrer le jeu
            updateColor();
        }

        // Jeu Tetris
        function initTetris() {
            // Éléments du DOM
            const canvas = document.getElementById('tetris-board');
            const ctx = canvas.getContext('2d');
            const nextPieceEl = document.getElementById('next-piece');
            const scoreDisplay = document.getElementById('tetris-score-display');
            const levelDisplay = document.getElementById('tetris-level-display');
            const finalScoreDisplay = document.getElementById('tetris-final-score');
            const gameOverScreen = document.getElementById('tetris-game-over');
            const startScreen = document.getElementById('tetris-start-screen');
            const startBtn = document.getElementById('tetris-start-btn');
            const restartBtn = document.getElementById('tetris-restart-btn');
            const pauseBtn = document.getElementById('tetris-pause-btn');
            const newGameBtn = document.getElementById('tetris-new-game-btn');
            
            // Configuration du jeu
            const blockSize = 30;
            const cols = canvas.width / blockSize;
            const rows = canvas.height / blockSize;
            
            // Variables du jeu
            let board = Array(rows).fill().map(() => Array(cols).fill(0));
            let currentPiece = null;
            let nextPiece = null;
            let piecePos = { x: 0, y: 0 };
            let score = 0;
            let level = 1;
            let lines = 0;
            let dropCounter = 0;
            let dropInterval = 1000;
            let lastTime = 0;
            let animationId = null;
            let isPaused = false;
            let gameOver = false;
            let gameStarted = false;
            
            // Pièces du Tetris
            const pieces = [
                { 
                    shape: [[1, 1, 1, 1]], 
                    color: '#00F0FF'
                },
                { 
                    shape: [[1, 0, 0], [1, 1, 1]], 
                    color: '#0000FF'
                },
                { 
                    shape: [[0, 0, 1], [1, 1, 1]], 
                    color: '#FF8000'
                },
                { 
                    shape: [[1, 1], [1, 1]], 
                    color: '#FFFF00'
                },
                { 
                    shape: [[0, 1, 1], [1, 1, 0]], 
                    color: '#00FF00'
                },
                { 
                    shape: [[0, 1, 0], [1, 1, 1]], 
                    color: '#8000FF'
                },
                { 
                    shape: [[1, 1, 0], [0, 1, 1]], 
                    color: '#FF0000'
                }
            ];
            
            // Obtenir une pièce aléatoire
            function getRandomPiece() {
                const piece = pieces[Math.floor(Math.random() * pieces.length)];
                return {
                    shape: piece.shape,
                    color: piece.color
                };
            }
            
            // Dessiner le plateau
            function drawBoard() {
                // Fond
                ctx.fillStyle = '#1A1A23';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Grille
                ctx.strokeStyle = '#2B2B36';
                ctx.lineWidth = 1;
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
                    }
                }
                
                // Pièces placées
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        if (board[y][x]) {
                            drawBlock(x, y, board[y][x]);
                        }
                    }
                }
                
                // Pièce courante
                if (currentPiece) {
                    currentPiece.shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value) {
                                drawBlock(
                                    piecePos.x + x,
                                    piecePos.y + y,
                                    currentPiece.color
                                );
                            }
                        });
                    });
                }
            }
            
            // Dessiner un bloc
            function drawBlock(x, y, color) {
                ctx.fillStyle = color;
                ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
                
                // Effet 3D
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(x * blockSize, y * blockSize, blockSize, 3);
                ctx.fillRect(x * blockSize, y * blockSize, 3, blockSize);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(x * blockSize + 3, y * blockSize + blockSize - 3, blockSize - 3, 3);
                ctx.fillRect(x * blockSize + blockSize - 3, y * blockSize + 3, 3, blockSize - 6);
                
                // Bordure
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
            }
            
            // Mettre à jour l'affichage de la prochaine pièce
            function updateNextPiece() {
                nextPieceEl.innerHTML = '';
                
                if (!nextPiece) return;
                
                const pieceDiv = document.createElement('div');
                pieceDiv.style.width = '120px';
                pieceDiv.style.height = '120px';
                pieceDiv.style.position = 'relative';
                
                nextPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            const block = document.createElement('div');
                            block.style.position = 'absolute';
                            block.style.left = `${x * 30}px`;
                            block.style.top = `${y * 30}px`;
                            block.style.width = '30px';
                            block.style.height = '30px';
                            block.style.backgroundColor = nextPiece.color;
                            block.style.borderRadius = '3px';
                            pieceDiv.appendChild(block);
                        }
                    });
                });
                
                nextPieceEl.appendChild(pieceDiv);
            }
            
            // Vérifier les collisions
            function collision() {
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const boardX = piecePos.x + x;
                            const boardY = piecePos.y + y;
                            
                            if (
                                boardX < 0 ||
                                boardX >= cols ||
                                boardY >= rows ||
                                (boardY >= 0 && board[boardY][boardX])
                            ) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // Rotation de la pièce
            function rotatePiece() {
                if (isPaused || !gameStarted) return;
                
                const originalShape = currentPiece.shape;
                const rows = currentPiece.shape.length;
                const cols = currentPiece.shape[0].length;
                const newShape = Array(cols).fill().map(() => Array(rows).fill(0));
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        newShape[x][rows - 1 - y] = currentPiece.shape[y][x];
                    }
                }
                
                currentPiece.shape = newShape;
                
                if (collision()) {
                    currentPiece.shape = originalShape;
                }
            }
            
            // Fusionner la pièce avec le plateau
            function merge() {
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            const boardY = piecePos.y + y;
                            const boardX = piecePos.x + x;
                            if (boardY >= 0) {
                                board[boardY][boardX] = currentPiece.color;
                            }
                        }
                    });
                });
            }
            
            // Supprimer les lignes complètes
            function clearLines() {
                let linesCleared = 0;
                
                for (let y = rows - 1; y >= 0; y--) {
                    if (board[y].every(cell => cell !== 0)) {
                        board.splice(y, 1);
                        board.unshift(Array(cols).fill(0));
                        linesCleared++;
                        y++;
                    }
                }
                
                if (linesCleared > 0) {
                    // Calcul du score
                    const points = [0, 40, 100, 300, 1200][linesCleared] * level;
                    score += points;
                    lines += linesCleared;
                    
                    // Augmentation du niveau
                    level = Math.floor(lines / 10) + 1;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                    
                    updateScore();
                }
            }
            
            // Mettre à jour le score
            function updateScore() {
                scoreDisplay.textContent = score;
                levelDisplay.textContent = `Niveau: ${level}`;
            }
            
            // Déplacement de la pièce
            function movePiece(dx, dy) {
                if (isPaused || !gameStarted) return false;
                
                piecePos.x += dx;
                piecePos.y += dy;
                
                if (collision()) {
                    piecePos.x -= dx;
                    piecePos.y -= dy;
                    
                    if (dy === 1) {
                        merge();
                        clearLines();
                        spawnPiece();
                    }
                    
                    return false;
                }
                
                return true;
            }
            
            // Faire apparaître une nouvelle pièce
            function spawnPiece() {
                currentPiece = nextPiece;
                nextPiece = getRandomPiece();
                piecePos.x = Math.floor(cols / 2) - Math.floor(currentPiece.shape[0].length / 2);
                piecePos.y = 0;
                
                // Vérifier le game over
                if (collision()) {
                    gameOver = true;
                    finalScoreDisplay.textContent = `Score: ${score}`;
                    gameOverScreen.style.display = 'flex';
                }
                
                updateNextPiece();
            }
            
            // Tomber rapidement
            function hardDrop() {
                if (isPaused || !gameStarted) return;
                
                while (movePiece(0, 1)) {}
            }
            
            // Basculer pause
            function togglePause() {
                if (!gameStarted || gameOver) return;
                
                isPaused = !isPaused;
                pauseBtn.textContent = isPaused ? 'REPRENDRE' : 'PAUSE';
                
                if (!isPaused) {
                    lastTime = performance.now();
                    gameLoop();
                }
            }
            
            // Boucle de jeu principale
            function gameLoop(time = 0) {
                if (gameOver) return;
                if (isPaused) {
                    animationId = requestAnimationFrame(gameLoop);
                    return;
                }
                
                const deltaTime = time - lastTime;
                lastTime = time;
                
                dropCounter += deltaTime;
                if (dropCounter > dropInterval) {
                    movePiece(0, 1);
                    dropCounter = 0;
                }
                
                drawBoard();
                animationId = requestAnimationFrame(gameLoop);
            }
            
            // Gestion des touches
            document.addEventListener('keydown', e => {
                if (!gameStarted && e.key === 'Enter') {
                    startGame();
                    return;
                }
                
                if (gameOver && e.key === 'Enter') {
                    startGame();
                    return;
                }
                
                if (!gameStarted || gameOver) return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                        movePiece(-1, 0);
                        break;
                    case 'ArrowRight':
                        movePiece(1, 0);
                        break;
                    case 'ArrowDown':
                        movePiece(0, 1);
                        dropCounter = 0;
                        break;
                    case 'ArrowUp':
                        rotatePiece();
                        break;
                    case ' ':
                        hardDrop();
                        break;
                    case 'p':
                    case 'P':
                        togglePause();
                        break;
                }
            });
            
            // Démarrer une nouvelle partie
            function startGame() {
                board = Array(rows).fill().map(() => Array(cols).fill(0));
                score = 0;
                level = 1;
                lines = 0;
                dropInterval = 1000;
                dropCounter = 0;
                gameOver = false;
                isPaused = false;
                gameStarted = true;
                
                currentPiece = getRandomPiece();
                nextPiece = getRandomPiece();
                spawnPiece();
                
                updateScore();
                updateNextPiece();
                
                startScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                
                lastTime = performance.now();
                if (animationId) cancelAnimationFrame(animationId);
                gameLoop();
            }
            
            // Événements des boutons
            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', startGame);
            pauseBtn.addEventListener('click', togglePause);
            newGameBtn.addEventListener('click', startGame);
            
            // Dessiner l'écran de démarrage
            drawBoard();
        }

        // Jeu Banana Clicker
        function initBananaClicker() {
            // Variables du jeu
            let gameState = {
                bananas: 0,
                totalClicks: 0,
                bananasPerSecond: 0,
                multiplier: 1,
                goldenBananas: 0,
                diamondBananas: 0, // Nouveau type de monnaie premium
                upgrades: {},
                achievements: {}, // Suivi des succès débloqués
                activeEvents: [], // Événements actifs
                stats: {
                    totalBananasEarned: 0,
                    totalPrestigesPerformed: 0,
                    bestBananaPerSecond: 0,
                    biggestCriticalClick: 0
                },
                lastUpdate: Date.now()
            };
            
            // Améliorations disponibles
            const upgrades = [
                { 
                    id: 'monkey', 
                    name: 'Singe Assistant', 
                    description: 'On a tous la blague', 
                    baseCost: 500, 
                    bps: 0.1,
                    icon: 'fas fa-paw'
                },
                { 
                    id: 'farm', 
                    name: 'Ferme Bananière', 
                    description: 'Une plantation de bananes basique avec deux coups de fouets quand même', 
                    baseCost: 1000, 
                    bps: 0.5,
                    icon: 'fas fa-tractor'
                },
                { 
                    id: 'factory', 
                    name: 'Usine de Bananes', 
                    description: 'Une histoire de famille', 
                    baseCost: 5000, 
                    bps: 1,
                    icon: 'fas fa-industry'
                },
                { 
                    id: 'plantation', 
                    name: 'Plantation Géante', 
                    description: 'Maintenant ils ont le droit d acheter des esclaves ?', 
                    baseCost: 10000, 
                    bps: 5,
                    icon: 'fas fa-globe-americas'
                },
                { 
                    id: 'research', 
                    name: 'Laboratoire de Recherche', 
                    description: 'Three hundred bl*ck men for only.......', 
                    baseCost: 50000, 
                    bps: 10,
                    icon: 'fas fa-flask'
                },
                { 
                    id: 'portal', 
                    name: 'La tortue', 
                    description: 'Tu as du mal à voir l ecran avance, ta tête comme Franklin Prime', 
                    baseCost: 100000, 
                    bps: 15,
                    icon: 'fas fa-door-open'
                },
                
                { 
                    id: 'timetravel', 
                    name: 'Machine à Voyager dans le Temps', 
                    description: 'POV, tu roules en Peugeot 1007, tu casses une suspension, tu décides de remonter le temps pour manger un giga tacos taille XXXXXL', 
                    baseCost: 1000000, 
                    bps: 100,
                    icon: 'fas fa-clock'
                },
                { 
                    id: 'galaxy', 
                    name: 'La Galaxie', 
                    description: 'Ton ventre est un trou noir, Tu fait 1m ta fait ton sport du mois tu doit certainement être..... ', 
                    baseCost: 5000000, 
                    bps: 250,
                    icon: 'fas fa-star'
                },
           
                { 
                    id: 'cisco', 
                    name: 'Cisco Paquet Tracer', 
                    description: 'Tu te branle sur la fibre, tu fais du speedtest, tu décide de mettre un paquet tracer ', 
                    baseCost: 10000000, 
                    bps: 500,
                    icon: ''
                },
                { 
                    id: 'Essaie', 
                    name: 'Essaie', 
                    description: 'Imagine tu fais un essaie en français et tu ose écrire 37 lignes ', 
                    baseCost: 37000000, 
                    bps: 1000,
                    icon: ''
                },
                { 
                    id: 'inflation', 
                    name: 'L inflation', 
                    description: 'Là, tu es dans la merde donc tu décide d augmenter le SMIC ', 
                    baseCost: 100000000, 
                    bps: 2000,
                    icon: ''
                },
                { 
                    id: 'viande', 
                    name: 'Banana Viande', 
                    description: 'Tu connais la blague mais le score fiscal est pas bon (E) ', 
                    baseCost: 250000000, 
                    bps: 3000,
                    icon: ''
                },
                { 
                    id: 'KFC', 
                    name: 'Le Poulet', 
                    description: 'Maintenant que tu as percer dans les bananes tu décide de partir dans une autre de tes cultures. ', 
                    baseCost: 500000000, 
                    bps: 5000,
                    icon: ''
                },
                { 
                    id: 'naj', 
                    name: 'Hobbies', 
                    description: 'La Natation et le vélo, mdr tu vide l eau de la piscine et tu détruit des suspension', 
                    baseCost: 1000000000, 
                    bps: 10000,
                    icon: ''
                },
                { 
                    id: 'chomeur', 
                    name: 'Chomeur de merde', 
                    description: 'La gros ta vraiment pas de vie', 
                    baseCost: 5000000000, 
                    bps: 100000,
                    icon: 'fas fa-door-open'
                },
                { 
                    id: 'data', 
                    name: 'Le data center SQL MariaDB', 
                    description: 'Quand tu respire il y à plus d air, tu frotte tes cuisses, tu mange pour 6, qui suis-je ?', 
                    baseCost: 100000000000, 
                    bps: 1000000,
                    icon: 'fas fa-door-open'
                },
                { 
                    id: 'Pierre', 
                    name: 'Le Caillou', 
                    description: 'Ecoute moi bien grosse merde je te déteste a farme autant', 
                    baseCost: 100000000000000, 
                    bps: 1000000,
                    icon: 'fas fa-door-open'
                },
            ];
            
            // Améliorations spéciales
            const specialUpgrades = [
                {
                    id: 'multiplier',
                    name: 'Multiplicateur',
                    description: 'Augmente la valeur de chaque clic de 0.1x',
                    baseCost: 1000,
                    maxLevel: 10,
                    icon: 'fas fa-times-circle'
                },
                {
                    id: 'click-power',
                    name: 'Puissance de Clic',
                    description: 'Double occasionnellement les bananes gagnées par clic',
                    baseCost: 5000,
                    maxLevel: 5,
                    icon: 'fas fa-bolt'
                },
                {
                    id: 'auto-click',
                    name: 'Auto-Clicker',
                    description: 'Clique automatiquement toutes les 10 secondes',
                    baseCost: 15000,
                    maxLevel: 5,
                    icon: 'fas fa-mouse-pointer'
                },
                {
                    id: 'golden-chance',
                    name: 'Chance Dorée',
                    description: 'Augmente la chance d\'obtenir des bananes dorées en cliquant',
                    baseCost: 25000,
                    maxLevel: 5,
                    icon: 'fas fa-dice'
                }
            ];
            
            // Événements aléatoires
            const randomEvents = [
                {
                    id: 'banana-rain',
                    name: 'Pluie de Bananes',
                    description: 'La production de bananes est doublée pendant 30 secondes!',
                    duration: 30000,
                    effect: () => {
                        const oldBps = gameState.bananasPerSecond;
                        updateBananasPerSecond();
                        gameState.bananasPerSecond *= 2;
                        return () => {
                            gameState.bananasPerSecond = oldBps;
                            updateBananasPerSecond();
                        };
                    },
                    backgroundColor: 'rgba(255, 215, 0, 0.2)',
                    icon: 'fas fa-cloud-rain'
                },
                {
                    id: 'click-frenzy',
                    name: 'Frénésie de Clics',
                    description: 'Les clics valent 3x plus pendant 20 secondes!',
                    duration: 20000,
                    effect: () => {
                        const oldMultiplier = gameState.multiplier;
                        gameState.multiplier *= 3;
                        return () => {
                            gameState.multiplier = oldMultiplier;
                        };
                    },
                    backgroundColor: 'rgba(255, 69, 0, 0.2)',
                    icon: 'fas fa-hand-pointer'
                },
                {
                    id: 'golden-rush',
                    name: 'Ruée vers l\'Or',
                    description: 'Chance de gagner des bananes dorées en cliquant!',
                    duration: 15000,
                    effect: () => {
                        // Logique gérée dans handleBananaClick
                        return () => {};
                    },
                    backgroundColor: 'rgba(218, 165, 32, 0.2)',
                    icon: 'fas fa-coins'
                }
            ];
            
            // Succès à débloquer
            const achievements = [
                {
                    id: 'first-banana',
                    name: 'Première Banane',
                    description: 'Cliquez pour obtenir votre première banane',
                    condition: () => gameState.totalClicks >= 1,
                    reward: 'Une banane de bienvenue!',
                    icon: 'fas fa-hand-point-up'
                },
                {
                    id: 'banana-addict',
                    name: 'Accro aux Bananes',
                    description: 'Cliquez 100 fois',
                    condition: () => gameState.totalClicks >= 100,
                    reward: 'Augmentation de votre multiplicateur de 0.1x',
                    icon: 'fas fa-hand-rock',
                    effect: () => { gameState.multiplier += 0.1; }
                },
                {
                    id: 'banana-master',
                    name: 'Maître des Bananes',
                    description: 'Cliquez 1,000 fois',
                    condition: () => gameState.totalClicks >= 1000,
                    reward: 'Augmentation de votre multiplicateur de 0.2x',
                    icon: 'fas fa-crown',
                    effect: () => { gameState.multiplier += 0.2; }
                },
                {
                    id: 'banana-king',
                    name: 'Roi des Bananes',
                    description: 'Atteignez 1 million de bananes',
                    condition: () => gameState.bananas >= 1000000,
                    reward: 'Débloquez le prestige!',
                    icon: 'fas fa-chess-king'
                },
                {
                    id: 'golden-collector',
                    name: 'Collectionneur Doré',
                    description: 'Obtenez 10 bananes dorées',
                    condition: () => gameState.goldenBananas >= 10,
                    reward: 'Augmentation du multiplicateur de prestige de 0.2x',
                    icon: 'fas fa-gem',
                    effect: () => { gameState.multiplier += 0.2; }
                },
                {
                    id: 'upgrade-enthusiast',
                    name: 'Passionné d\'Améliorations',
                    description: 'Achetez un total de 50 améliorations',
                    condition: () => {
                        let totalUpgrades = 0;
                        for (let id in gameState.upgrades) {
                            if (gameState.upgrades[id].owned) {
                                totalUpgrades += gameState.upgrades[id].owned;
                            }
                        }
                        return totalUpgrades >= 50;
                    },
                    reward: 'Réduction de 5% sur tous les achats futurs',
                    icon: 'fas fa-arrow-circle-up',
                    effect: () => { gameState.discountMultiplier = 0.95; }
                }
            ];
            
            // Éléments du DOM
            const bananaElement = document.getElementById('banana');
            const bananaCounter = document.getElementById('banana-counter');
            const bananaBps = document.getElementById('banana-bps');
            const totalClicksElement = document.getElementById('banana-total-clicks');
            const multiplierElement = document.getElementById('banana-multiplier');
            const goldenBananasElement = document.getElementById('banana-golden');
            const upgradesContainer = document.getElementById('banana-upgrades-container');
            const specialUpgradesContainer = document.getElementById('banana-special-upgrades-container');
            const prestigeBtn = document.getElementById('prestige-btn');
            const prestigeRequirement = document.getElementById('prestige-requirement');
            const prestigeReward = document.getElementById('prestige-reward');
            
            // Charger la sauvegarde
            function loadSave() {
                const save = localStorage.getItem('bananaClickerSave');
                if (save) {
                    const data = JSON.parse(save);
                    gameState = {
                        ...gameState,
                        ...data,
                        lastUpdate: Date.now()
                    };
                    
                    // Mise à jour des BPS après chargement
                    updateBananasPerSecond();
                    updateDisplay();
                }
            }
            
            // Sauvegarder le jeu
            function saveGame() {
                localStorage.setItem('bananaClickerSave', JSON.stringify({
                    ...gameState,
                    lastUpdate: Date.now()
                }));
            }
            
            // Sauvegarder périodiquement et avant de quitter
            setInterval(saveGame, 30000);
            window.addEventListener('beforeunload', saveGame);
            
            // Mettre à jour l'affichage
            function updateDisplay() {
                bananaCounter.textContent = `${formatNumber(gameState.bananas)} bananes`;
                bananaBps.textContent = `${gameState.bananasPerSecond.toFixed(1)} bananes/seconde`;
                totalClicksElement.textContent = gameState.totalClicks;
                multiplierElement.textContent = `${gameState.multiplier.toFixed(1)}x`;
                goldenBananasElement.textContent = gameState.goldenBananas;
                
                // Mettre à jour les boutons d'amélioration
                upgrades.forEach(upgrade => {
                    const btn = document.getElementById(`${upgrade.id}-btn`);
                    if (btn) {
                        const cost = getUpgradeCost(upgrade);
                        btn.disabled = gameState.bananas < cost;
                    }
                });
                
                // Mettre à jour les boutons d'améliorations spéciales
                specialUpgrades.forEach(upgrade => {
                    const btn = document.getElementById(`special-${upgrade.id}-btn`);
                    if (btn) {
                        const cost = getSpecialUpgradeCost(upgrade);
                        const level = gameState.upgrades[upgrade.id]?.level || 0;
                        btn.disabled = gameState.bananas < cost || level >= upgrade.maxLevel;
                        btn.textContent = level >= upgrade.maxLevel ? 'MAX' : `Améliorer (${formatNumber(cost)})`;
                    }
                });
                
                // Mettre à jour le bouton de prestige
                const canPrestige = gameState.bananas >= 100000000;
                prestigeBtn.disabled = !canPrestige;
                prestigeRequirement.textContent = canPrestige 
                    ? 'Vous pouvez effectuer un prestige!' 
                    : 'Vous avez besoin d\'au moins 1,000,000,000 bananes pour effectuer un prestige.';
                
                const goldenBananasEarned = Math.floor(Math.sqrt(gameState.bananas / 1000000)); // Formule améliorée
                prestigeReward.textContent = `Vous obtiendrez ${goldenBananasEarned} Bananes Dorées`;
                
                // Mettre à jour l'affichage des événements actifs
                updateActiveEvents();
                
                // Vérifier les succès
                checkAchievements();
            }
            
            // Formater les grands nombres
            function formatNumber(num) {
                if (num >= 1000000000) {
                    return (num / 1000000000).toFixed(1) + 'B';
                }
                if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M';
                }
                if (num >= 1000) {
                    return (num / 1000).toFixed(1) + 'K';
                }
                return Math.floor(num).toString();
            }
            
            // Calculer le coût d'une amélioration
            function getUpgradeCost(upgrade) {
                const owned = gameState.upgrades[upgrade.id]?.owned || 0;
                let cost = Math.floor(upgrade.baseCost * Math.pow(1.15, owned));
                
                // Appliquer une réduction si le succès correspondant est débloqué
                if (gameState.discountMultiplier) {
                    cost = Math.floor(cost * gameState.discountMultiplier);
                }
                
                return cost;
            }
            
            // Calculer le coût d'une amélioration spéciale
            function getSpecialUpgradeCost(upgrade) {
                const level = gameState.upgrades[upgrade.id]?.level || 0;
                let cost = upgrade.baseCost * Math.pow(2, level);
                
                // Appliquer une réduction si le succès correspondant est débloqué
                if (gameState.discountMultiplier) {
                    cost = Math.floor(cost * gameState.discountMultiplier);
                }
                
                return cost;
            }
            
            // Mettre à jour les bananes par seconde
            function updateBananasPerSecond() {
                let bps = upgrades.reduce((total, upgrade) => {
                    const owned = gameState.upgrades[upgrade.id]?.owned || 0;
                    return total + (upgrade.bps * owned);
                }, 0);
                
                // Bonus du prestige
                bps *= (1 + (gameState.goldenBananas * 0.1));
                
                gameState.bananasPerSecond = bps;
                
                // Mettre à jour les statistiques
                if (bps > gameState.stats.bestBananaPerSecond) {
                    gameState.stats.bestBananaPerSecond = bps;
                }
            }
            
            // Gérer le clic sur la banane
            function handleBananaClick() {
                let gain = gameState.multiplier;
                let isCritical = false;
                
                // Chance de coup critique
                const clickPowerLevel = gameState.upgrades['click-power']?.level || 0;
                if (clickPowerLevel > 0 && Math.random() < 0.1 * clickPowerLevel) {
                    gain *= 2;
                    isCritical = true;
                    
                    // Mettre à jour les statistiques
                    if (gain > gameState.stats.biggestCriticalClick) {
                        gameState.stats.biggestCriticalClick = gain;
                    }
                    
                    // Effet spécial
                    const clickEffect = document.createElement('div');
                    clickEffect.className = 'click-effect special';
                    clickEffect.textContent = `CRITIQUE! +${gain.toFixed(1)}`;
                    clickEffect.style.left = `${Math.random() * 100 + 50}px`;
                    clickEffect.style.color = 'gold';
                    document.getElementById('banana-container').appendChild(clickEffect);
                    
                    setTimeout(() => {
                        clickEffect.remove();
                    }, 2000);
                    
                    playSound(specialSound);
                } else {
                    // Effet normal
                    const clickEffect = document.createElement('div');
                    clickEffect.className = 'click-effect';
                    clickEffect.textContent = `+${gain.toFixed(1)}`;
                    clickEffect.style.left = `${Math.random() * 100 + 50}px`;
                    clickEffect.style.color = `hsl(${Math.random() * 60 + 30}, 100%, 50%)`;
                    document.getElementById('banana-container').appendChild(clickEffect);
                    
                    setTimeout(() => {
                        clickEffect.remove();
                    }, 1500);
                    
                    playSound(clickSound);
                }
                
                // Vérifier si l'événement "Ruée vers l'Or" est actif
                if (gameState.activeEvents.find(e => e.id === 'golden-rush') && Math.random() < 0.1) {
                    gameState.goldenBananas += 1;
                    
                    const goldEffect = document.createElement('div');
                    goldEffect.className = 'click-effect special';
                    goldEffect.textContent = '+1 🍌 DORÉE!';
                    goldEffect.style.left = `${Math.random() * 100 + 50}px`;
                    goldEffect.style.color = '#FFD700';
                    document.getElementById('banana-container').appendChild(goldEffect);
                    
                    setTimeout(() => {
                        goldEffect.remove();
                    }, 2500);
                    
                    playSound(specialSound);
                }
                
                // Chance de trouver une banane dorée basée sur l'amélioration spéciale
                const goldenChanceLevel = gameState.upgrades['golden-chance']?.level || 0;
                if (goldenChanceLevel > 0 && Math.random() < 0.005 * goldenChanceLevel) {
                    gameState.goldenBananas += 1;
                    
                    const goldEffect = document.createElement('div');
                    goldEffect.className = 'click-effect special';
                    goldEffect.textContent = '+1 🍌 DORÉE!';
                    goldEffect.style.left = `${Math.random() * 100 + 50}px`;
                    goldEffect.style.color = '#FFD700';
                    document.getElementById('banana-container').appendChild(goldEffect);
                    
                    setTimeout(() => {
                        goldEffect.remove();
                    }, 2500);
                    
                    playSound(specialSound);
                }
                
                // Animation de pulsation sur la banane
                bananaElement.style.transform = 'scale(0.92)';
                setTimeout(() => {
                    bananaElement.style.transform = 'scale(1)';
                }, 100);
                
                gameState.bananas += gain;
                gameState.totalClicks++;
                gameState.stats.totalBananasEarned += gain;
                
                updateDisplay();
                saveGame();
                
                // Vérifier si un événement aléatoire doit apparaître
                if (Math.random() < 0.005 && gameState.activeEvents.length === 0) {
                    triggerRandomEvent();
                }
            }
            
            // Acheter une amélioration
            function buyUpgrade(upgradeId) {
                const upgrade = upgrades.find(u => u.id === upgradeId);
                if (!upgrade) return;
                
                const cost = getUpgradeCost(upgrade);
                
                if (gameState.bananas >= cost) {
                    gameState.bananas -= cost;
                    
                    if (!gameState.upgrades[upgrade.id]) {
                        gameState.upgrades[upgrade.id] = { owned: 0 };
                    }
                    
                    gameState.upgrades[upgrade.id].owned++;
                    
                    updateBananasPerSecond();
                    updateDisplay();
                    saveGame();
                    playSound(upgradeSound);
                }
            }
            
            // Acheter une amélioration spéciale
            function buySpecialUpgrade(upgradeId) {
                const upgrade = specialUpgrades.find(u => u.id === upgradeId);
                if (!upgrade) return;
                
                const cost = getSpecialUpgradeCost(upgrade);
                const level = gameState.upgrades[upgrade.id]?.level || 0;
                
                if (level >= upgrade.maxLevel) return;
                
                if (gameState.bananas >= cost) {
                    gameState.bananas -= cost;
                    
                    if (!gameState.upgrades[upgrade.id]) {
                        gameState.upgrades[upgrade.id] = { level: 0 };
                    }
                    
                    gameState.upgrades[upgrade.id].level++;
                    
                    // Appliquer l'effet de l'amélioration
                    if (upgradeId === 'multiplier') {
                        gameState.multiplier += 0.1;
                    }
                    
                    updateDisplay();
                    saveGame();
                    playSound(upgradeSound);
                }
            }
            
            // Effectuer un prestige
            function prestige() {
                if (gameState.bananas < 1000000) return;
                
                const goldenBananasEarned = Math.floor(Math.sqrt(gameState.bananas / 1000000));
                
                if (confirm(`Voulez-vous vraiment effectuer un prestige? Vous obtiendrez ${goldenBananasEarned} Bananes Dorées mais perdrez toutes vos bananes et améliorations.`)) {
                    gameState.goldenBananas += goldenBananasEarned;
                    gameState.bananas = 0;
                    gameState.totalClicks = 0;
                    gameState.bananasPerSecond = 0;
                    gameState.multiplier = 1 + (gameState.goldenBananas * 0.1); // Bonus de prestige
                    gameState.upgrades = {};
                    gameState.activeEvents = [];
                    
                    // Mettre à jour les statistiques
                    gameState.stats.totalPrestigesPerformed++;
                    
                    updateBananasPerSecond();
                    updateDisplay();
                    saveGame();
                    playSound(prestigeSound);
                    
                    // Re-rendre les améliorations
                    renderUpgrades();
                    renderSpecialUpgrades();
                    
                    // Afficher un message de félicitations
                    showNotification(`Prestige réussi! Vous avez gagné ${goldenBananasEarned} Bananes Dorées.`);
                }
            }
            
            // Déclencher un événement aléatoire
            function triggerRandomEvent() {
                // Sélectionner un événement aléatoire
                const event = randomEvents[Math.floor(Math.random() * randomEvents.length)];
                
                // Appliquer l'effet de l'événement
                const cleanup = event.effect();
                
                // Ajouter l'événement à la liste des événements actifs
                gameState.activeEvents.push({
                    id: event.id,
                    name: event.name,
                    description: event.description,
                    icon: event.icon,
                    backgroundColor: event.backgroundColor,
                    endTime: Date.now() + event.duration,
                    cleanup
                });
                
                // Mettre à jour l'affichage des événements
                updateActiveEvents();
                
                // Jouer un son
                playSound(specialSound);
                
                // Afficher une notification
                showNotification(`ÉVÉNEMENT: ${event.name} - ${event.description}`);
                
                // Planifier la fin de l'événement
                setTimeout(() => {
                    endEvent(event.id);
                }, event.duration);
            }
            
            // Mettre fin à un événement
            function endEvent(eventId) {
                const eventIndex = gameState.activeEvents.findIndex(e => e.id === eventId);
                if (eventIndex === -1) return;
                
                // Exécuter la fonction de nettoyage
                gameState.activeEvents[eventIndex].cleanup();
                
                // Supprimer l'événement de la liste
                gameState.activeEvents.splice(eventIndex, 1);
                
                // Mettre à jour l'affichage
                updateActiveEvents();
                updateDisplay();
            }
            
            // Mettre à jour l'affichage des événements actifs
            function updateActiveEvents() {
                // Créer ou obtenir le conteneur d'événements
                let eventsContainer = document.getElementById('banana-events-container');
                if (!eventsContainer) {
                    eventsContainer = document.createElement('div');
                    eventsContainer.id = 'banana-events-container';
                    eventsContainer.className = 'banana-events';
                    document.getElementById('banana-container').after(eventsContainer);
                }
                
                // Vider le conteneur
                eventsContainer.innerHTML = '';
                
                // Si aucun événement actif, cacher le conteneur
                if (gameState.activeEvents.length === 0) {
                    eventsContainer.style.display = 'none';
                    return;
                }
                
                // Afficher le conteneur
                eventsContainer.style.display = 'block';
                
                // Ajouter chaque événement actif
                gameState.activeEvents.forEach(event => {
                    const eventElement = document.createElement('div');
                    eventElement.className = 'banana-event';
                    eventElement.style.backgroundColor = event.backgroundColor;
                    
                    // Calculer le temps restant
                    const remainingTime = Math.max(0, Math.floor((event.endTime - Date.now()) / 1000));
                    
                    eventElement.innerHTML = `
                        <div class="event-icon"><i class="${event.icon}"></i></div>
                        <div class="event-info">
                            <h4>${event.name}</h4>
                            <p>${event.description}</p>
                            <div class="event-timer">${remainingTime}s</div>
                        </div>
                    `;
                    
                    eventsContainer.appendChild(eventElement);
                });
            }
            
            // Vérifier les succès débloqués
            function checkAchievements() {
                achievements.forEach(achievement => {
                    // Si le succès est déjà débloqué, passer
                    if (gameState.achievements[achievement.id]) return;
                    
                    // Vérifier si la condition est remplie
                    if (achievement.condition()) {
                        // Marquer le succès comme débloqué
                        gameState.achievements[achievement.id] = {
                            unlocked: true,
                            date: Date.now()
                        };
                        
                        // Appliquer l'effet du succès si défini
                        if (achievement.effect) {
                            achievement.effect();
                        }
                        
                        // Montrer une notification
                        showAchievementNotification(achievement);
                        
                        // Mettre à jour l'affichage
                        updateDisplay();
                        saveGame();
                    }
                });
            }
            
            // Afficher une notification de succès
            function showAchievementNotification(achievement) {
                const notification = document.createElement('div');
                notification.className = 'achievement-notification';
                notification.innerHTML = `
                    <div class="achievement-icon"><i class="${achievement.icon}"></i></div>
                    <div class="achievement-info">
                        <h4>Succès débloqué: ${achievement.name}</h4>
                        <p>${achievement.description}</p>
                        <p class="achievement-reward">${achievement.reward}</p>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                // Animation d'entrée
                setTimeout(() => {
                    notification.style.transform = 'translateX(0)';
                    notification.style.opacity = '1';
                    playSound(specialSound);
                }, 100);
                
                // Supprimer après un délai
                setTimeout(() => {
                    notification.style.transform = 'translateX(120%)';
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        notification.remove();
                    }, 500);
                }, 5000);
            }
            
            // Afficher une notification générale
            function showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'game-notification';
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                // Animation d'entrée
                setTimeout(() => {
                    notification.style.transform = 'translateY(0)';
                    notification.style.opacity = '1';
                }, 100);
                
                // Supprimer après un délai
                setTimeout(() => {
                    notification.style.transform = 'translateY(-100%)';
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        notification.remove();
                    }, 500);
                }, 3000);
            }
            
            // Fonction d'auto-clic basée sur l'amélioration
            function handleAutoClick() {
                const autoClickLevel = gameState.upgrades['auto-click']?.level || 0;
                if (autoClickLevel > 0) {
                    // Simuler un clic toutes les 10 secondes, moins 1 seconde par niveau
                    const clickInterval = Math.max(1000, 10000 - (autoClickLevel * 1000));
                    
                    setInterval(() => {
                        // Un clic automatique vaut 50% d'un clic normal
                        let gain = gameState.multiplier * 0.5;
                        gameState.bananas += gain;
                        gameState.stats.totalBananasEarned += gain;
                        
                        // Petit effet visuel
                        const clickEffect = document.createElement('div');
                        clickEffect.className = 'click-effect';
                        clickEffect.textContent = `AUTO +${gain.toFixed(1)}`;
                        clickEffect.style.left = `${Math.random() * 100 + 50}px`;
                        clickEffect.style.color = `hsl(200, 80%, 60%)`;
                        document.getElementById('banana-container').appendChild(clickEffect);
                        
                        setTimeout(() => {
                            clickEffect.remove();
                        }, 1500);
                        
                        updateDisplay();
                    }, clickInterval);
                }
            }
            
            // Générer les cartes d'amélioration
            function renderUpgrades() {
                upgradesContainer.innerHTML = '';
                
                upgrades.forEach(upgrade => {
                    const owned = gameState.upgrades[upgrade.id]?.owned || 0;
                    const cost = getUpgradeCost(upgrade);
                    const canAfford = gameState.bananas >= cost;
                    
                    const upgradeElement = document.createElement('div');
                    upgradeElement.className = 'banana-upgrade';
                    upgradeElement.innerHTML = `
                        <h4 class="banana-upgrade-title"><i class="${upgrade.icon}"></i> ${upgrade.name}</h4>
                        <p class="banana-upgrade-desc">${upgrade.description}</p>
                        <div class="banana-upgrade-info">
                            <span class="banana-upgrade-cost">Coût: ${formatNumber(cost)}</span>
                            <span class="banana-upgrade-owned">Possédés: ${owned}</span>
                        </div>
                        <div class="banana-upgrade-info">
                            <span>Production: +${upgrade.bps}/s</span>
                            <span>Total: +${(upgrade.bps * owned).toFixed(1)}/s</span>
                        </div>
                        <button id="${upgrade.id}-btn" class="banana-btn ${canAfford ? 'can-afford' : ''}" onclick="buyBananaUpgrade('${upgrade.id}')" ${canAfford ? '' : 'disabled'}>
                            ${canAfford ? 'Acheter' : `Besoin de ${formatNumber(cost - gameState.bananas)} de plus`}
                        </button>
                    `;
                    
                    upgradesContainer.appendChild(upgradeElement);
                });
            }
            
            // Générer les améliorations spéciales
            function renderSpecialUpgrades() {
                specialUpgradesContainer.innerHTML = '';
                
                specialUpgrades.forEach(upgrade => {
                    const level = gameState.upgrades[upgrade.id]?.level || 0;
                    const cost = getSpecialUpgradeCost(upgrade);
                    const maxed = level >= upgrade.maxLevel;
                    const canAfford = gameState.bananas >= cost && !maxed;
                    
                    const upgradeElement = document.createElement('div');
                    upgradeElement.className = 'banana-upgrade';
                    upgradeElement.innerHTML = `
                        <h4 class="banana-upgrade-title"><i class="${upgrade.icon}"></i> ${upgrade.name} <small>Niv. ${level}/${upgrade.maxLevel}</small></h4>
                        <p class="banana-upgrade-desc">${upgrade.description}</p>
                        ${maxed ? `
                            <button class="banana-btn" disabled>MAX</button>
                        ` : `
                            <div class="banana-upgrade-info">
                                <span class="banana-upgrade-cost">Coût: ${formatNumber(cost)}</span>
                            </div>
                            <button id="special-${upgrade.id}-btn" class="banana-btn ${canAfford ? 'can-afford' : ''}" onclick="buyBananaSpecialUpgrade('${upgrade.id}')" ${canAfford ? '' : 'disabled'}>
                                ${canAfford ? 'Améliorer' : `Besoin de ${formatNumber(cost - gameState.bananas)} de plus`}
                            </button>
                        `}
                    `;
                    
                    specialUpgradesContainer.appendChild(upgradeElement);
                });
            }
            
            // Rendre les succès débloqués
            function renderAchievements() {
                // Créer ou obtenir le conteneur d'onglets
                let achievementsTab = document.getElementById('banana-achievements-tab');
                if (!achievementsTab) {
                    achievementsTab = document.createElement('div');
                    achievementsTab.id = 'banana-achievements-tab';
                    achievementsTab.className = 'banana-tab-content';
                    document.getElementById('banana-clicker-game').appendChild(achievementsTab);
                    
                    // Ajouter un bouton dans la barre d'onglets
                    const tabButton = document.createElement('button');
                    tabButton.className = 'banana-tab-btn';
                    tabButton.onclick = function() { openBananaTab('achievements'); };
                    tabButton.innerHTML = '<i class="fas fa-trophy"></i> Succès';
                    document.querySelector('.banana-tab-buttons').appendChild(tabButton);
                }
                
                achievementsTab.innerHTML = '<h3>Succès débloqués</h3>';
                
                // Conteneur pour les succès
                const achievementsContainer = document.createElement('div');
                achievementsContainer.className = 'banana-achievements';
                achievementsTab.appendChild(achievementsContainer);
                
                // Calculer le nombre de succès débloqués
                const unlockedCount = Object.keys(gameState.achievements).length;
                const totalCount = achievements.length;
                
                // Ajouter un compteur de succès
                const achievementCounter = document.createElement('div');
                achievementCounter.className = 'achievement-counter';
                achievementCounter.textContent = `${unlockedCount} / ${totalCount} succès débloqués`;
                achievementsTab.insertBefore(achievementCounter, achievementsContainer);
                
                // Ajouter chaque succès
                achievements.forEach(achievement => {
                    const isUnlocked = gameState.achievements[achievement.id];
                    
                    const achievementElement = document.createElement('div');
                    achievementElement.className = `banana-achievement ${isUnlocked ? 'unlocked' : 'locked'}`;
                    
                    if (isUnlocked) {
                        const date = new Date(gameState.achievements[achievement.id].date);
                        achievementElement.innerHTML = `
                            <div class="achievement-icon"><i class="${achievement.icon}"></i></div>
                            <div class="achievement-info">
                                <h4>${achievement.name}</h4>
                                <p>${achievement.description}</p>
                                <p class="achievement-reward">${achievement.reward}</p>
                                <p class="achievement-date">Débloqué le ${date.toLocaleDateString()}</p>
                            </div>
                        `;
                    } else {
                        achievementElement.innerHTML = `
                            <div class="achievement-icon"><i class="fas fa-question"></i></div>
                            <div class="achievement-info">
                                <h4>${achievement.name}</h4>
                                <p>${achievement.description}</p>
                            </div>
                        `;
                    }
                    
                    achievementsContainer.appendChild(achievementElement);
                });
            }
            
            // Ajouter un onglet de statistiques
            function renderStats() {
                // Créer ou obtenir le conteneur d'onglets
                let statsTab = document.getElementById('banana-stats-tab');
                if (!statsTab) {
                    statsTab = document.createElement('div');
                    statsTab.id = 'banana-stats-tab';
                    statsTab.className = 'banana-tab-content';
                    document.getElementById('banana-clicker-game').appendChild(statsTab);
                    
                    // Ajouter un bouton dans la barre d'onglets
                    const tabButton = document.createElement('button');
                    tabButton.className = 'banana-tab-btn';
                    tabButton.onclick = function() { openBananaTab('stats'); };
                    tabButton.innerHTML = '<i class="fas fa-chart-bar"></i> Statistiques';
                    document.querySelector('.banana-tab-buttons').appendChild(tabButton);
                }
                
                statsTab.innerHTML = '<h3>Statistiques du jeu</h3>';
                
                // Conteneur pour les statistiques
                const statsContainer = document.createElement('div');
                statsContainer.className = 'banana-stats-container';
                
                statsContainer.innerHTML = `
                    <div class="stat-item">
                        <div class="stat-label">Total de bananes gagnées</div>
                        <div class="stat-value">${formatNumber(gameState.stats.totalBananasEarned)}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Total de clics</div>
                        <div class="stat-value">${gameState.totalClicks}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Total de prestiges</div>
                        <div class="stat-value">${gameState.stats.totalPrestigesPerformed}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Meilleure production/sec</div>
                        <div class="stat-value">${gameState.stats.bestBananaPerSecond.toFixed(1)}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Plus gros clic critique</div>
                        <div class="stat-value">${gameState.stats.biggestCriticalClick.toFixed(1)}</div>
                    </div>
                `;
                
                statsTab.appendChild(statsContainer);
            }
            
            // Boucle de jeu pour les gains passifs
            function gameLoop() {
                const now = Date.now();
                const deltaTime = (now - gameState.lastUpdate) / 1000; // en secondes
                gameState.lastUpdate = now;
                
                if (gameState.bananasPerSecond > 0) {
                    gameState.bananas += gameState.bananasPerSecond * deltaTime;
                    gameState.stats.totalBananasEarned += gameState.bananasPerSecond * deltaTime;
                    updateDisplay();
                }
                
                // Mettre à jour les minuteurs d'événements
                if (gameState.activeEvents.length > 0) {
                    updateActiveEvents();
                }
                
                // Sauvegarder périodiquement
                if (now % 30000 < 100) { // ~toutes les 30 secondes
                    saveGame();
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            // Jouer un son
            function playSound(sound) {
                sound.currentTime = 0;
                sound.play().catch(e => console.log("Le son n'a pas pu être joué:", e));
            }
            
            // Exposer les fonctions au scope global
            window.buyBananaUpgrade = buyUpgrade;
            window.buyBananaSpecialUpgrade = buySpecialUpgrade;
            window.prestigeBananaClicker = prestige;
            window.openBananaTab = function(tabId) {
                document.querySelectorAll('#banana-clicker-game .banana-tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll('#banana-clicker-game .banana-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                document.querySelector(`#banana-clicker-game .banana-tab-btn[onclick="openBananaTab('${tabId}')"]`).classList.add('active');
                document.getElementById(`banana-${tabId}-tab`).classList.add('active');
            };
            
            // Initialiser le jeu
            loadSave();
            renderUpgrades();
            renderSpecialUpgrades();
            renderAchievements();
            renderStats();
            bananaElement.addEventListener('click', handleBananaClick);
            prestigeBtn.addEventListener('click', prestige);
            handleAutoClick();
            gameLoop();
            
            // Vérifier le temps d'absence (gains hors ligne)
            const offlineTime = (Date.now() - gameState.lastUpdate) / 1000;
            if (offlineTime > 60 && gameState.bananasPerSecond > 0) {
                // Limiter les gains hors ligne à 8 heures maximum
                const cappedTime = Math.min(offlineTime, 8 * 60 * 60);
                const offlineGains = gameState.bananasPerSecond * cappedTime * 0.5; // 50% d'efficacité hors ligne
                
                gameState.bananas += offlineGains;
                gameState.stats.totalBananasEarned += offlineGains;
                
                showNotification(`Bienvenue ! Vous avez gagné ${formatNumber(offlineGains)} bananes pendant votre absence.`);
            }
        }

        // Jeu de Test de Réaction
        function initReactionTest() {
            const reactionBox = document.getElementById('reaction-box');
            const lastTimeDisplay = document.getElementById('last-time');
            const bestTimeDisplay = document.getElementById('best-time');
            const averageTimeDisplay = document.getElementById('average-time');
            const messageDisplay = document.getElementById('reaction-message');
            const resetButton = document.getElementById('reset-reaction-btn');
            
            let state = 'waiting'; // waiting, ready, finished
            let timerStart = 0;
            let waitTimeout = null;
            let bestTime = localStorage.getItem('reactionBestTime') ? parseInt(localStorage.getItem('reactionBestTime')) : Infinity;
            let times = [];
            let avgTime = 0;
            
            if (bestTime !== Infinity) {
                bestTimeDisplay.textContent = `${bestTime} ms`;
            } else {
                bestTimeDisplay.textContent = '---';
            }
            
            function startTest() {
                reactionBox.classList.remove('ready', 'too-soon');
                reactionBox.classList.add('waiting');
                reactionBox.textContent = 'Attendez...';
                messageDisplay.textContent = 'Attendez que le carré devienne VERT, puis cliquez dessus rapidement!';
                state = 'waiting';
                
                // Temps d'attente aléatoire entre 1 et 4 secondes
                const randomTime = Math.floor(Math.random() * 3000) + 1000;
                waitTimeout = setTimeout(() => {
                    // Passage à l'état "prêt"
                    reactionBox.classList.remove('waiting');
                    reactionBox.classList.add('ready');
                    reactionBox.textContent = 'CLIQUEZ!';
                    state = 'ready';
                    timerStart = Date.now();
                }, randomTime);
            }
            
            function handleClick() {
                if (state === 'waiting') {
                    // Trop tôt!
                    clearTimeout(waitTimeout);
                    reactionBox.classList.remove('waiting');
                    reactionBox.classList.add('too-soon');
                    reactionBox.textContent = 'Trop tôt!';
                    messageDisplay.textContent = 'Vous avez cliqué trop tôt! Attendez que le carré devienne VERT.';
                    state = 'finished';
                } 
                else if (state === 'ready') {
                    // Mesurer le temps de réaction
                    const reactionTime = Date.now() - timerStart;
                    lastTimeDisplay.textContent = `${reactionTime} ms`;
                    
                    // Sauvegarder le meilleur temps
                    if (reactionTime < bestTime) {
                        bestTime = reactionTime;
                        bestTimeDisplay.textContent = `${bestTime} ms`;
                        localStorage.setItem('reactionBestTime', bestTime);
                    }
                    
                    // Calculer la moyenne
                    times.push(reactionTime);
                    if (times.length > 5) {
                        times.shift(); // Garder seulement les 5 dernières mesures
                    }
                    
                    avgTime = Math.round(times.reduce((sum, time) => sum + time, 0) / times.length);
                    averageTimeDisplay.textContent = `${avgTime} ms`;
                    
                    // Afficher un message selon la performance
                    if (reactionTime < 200) {
                        messageDisplay.textContent = 'Incroyable! Vos réflexes sont surhumains!';
                    } else if (reactionTime < 300) {
                        messageDisplay.textContent = 'Excellent! Vos réflexes sont exceptionnels!';
                    } else if (reactionTime < 400) {
                        messageDisplay.textContent = 'Très bon! Vous avez des réflexes au-dessus de la moyenne.';
                    } else if (reactionTime < 500) {
                        messageDisplay.textContent = 'Bien! Vos réflexes sont dans la moyenne.';
                    } else {
                        messageDisplay.textContent = 'Continuez à pratiquer pour améliorer vos réflexes!';
                    }
                    
                    reactionBox.textContent = 'Cliquez pour réessayer';
                    reactionBox.classList.remove('ready');
                    state = 'finished';
                } 
                else if (state === 'finished') {
                    startTest();
                }
            }
            
            function resetStats() {
                times = [];
                bestTime = Infinity;
                localStorage.removeItem('reactionBestTime');
                bestTimeDisplay.textContent = '---';
                lastTimeDisplay.textContent = '0 ms';
                averageTimeDisplay.textContent = '0 ms';
                messageDisplay.textContent = 'Cliquez sur le carré quand il devient VERT';
                
                reactionBox.classList.remove('waiting', 'ready', 'too-soon');
                reactionBox.textContent = 'Cliquez pour commencer';
                state = 'finished';
                clearTimeout(waitTimeout);
            }
            
            // Événements
            reactionBox.addEventListener('click', handleClick);
            resetButton.addEventListener('click', resetStats);
            
            // État initial
            reactionBox.textContent = 'Cliquez pour commencer';
            state = 'finished';
        }

        // Jeu de Blackjack
        function initBlackjack() {
            // Éléments du DOM
            const blackjackTable = document.getElementById('blackjack-table');
            const betContainer = document.getElementById('bet-container');
            const betInput = document.getElementById('blackjack-bet');
            const balanceElement = document.getElementById('blackjack-balance');
            const currentBetElement = document.getElementById('blackjack-current-bet');
            const gamesPlayedElement = document.getElementById('blackjack-games-played');
            const gamesWonElement = document.getElementById('blackjack-games-won');
            const hitBtn = document.getElementById('hit-btn');
            const standBtn = document.getElementById('stand-btn');
            const doubleBtn = document.getElementById('double-btn');
            const dealerCardsContainer = document.getElementById('dealer-cards');
            const playerCardsContainer = document.getElementById('player-cards');
            const dealerScoreElement = document.getElementById('dealer-score');
            const playerScoreElement = document.getElementById('player-score');
            const messageElement = document.getElementById('blackjack-message');
            const resultElement = document.getElementById('blackjack-result');
            const resultTitleElement = document.getElementById('result-title');
            const resultAmountElement = document.getElementById('result-amount');
            const playAgainBtn = document.getElementById('play-again-btn');
            
            // État du jeu
            const gameState = {
                balance: localStorage.getItem('blackjackBalance') ? parseInt(localStorage.getItem('blackjackBalance')) : 10000,
                currentBet: 0,
                gamesPlayed: localStorage.getItem('blackjackGamesPlayed') ? parseInt(localStorage.getItem('blackjackGamesPlayed')) : 0,
                gamesWon: localStorage.getItem('blackjackGamesWon') ? parseInt(localStorage.getItem('blackjackGamesWon')) : 0,
                deck: [],
                dealerCards: [],
                playerCards: [],
                dealerScore: 0,
                playerScore: 0,
                gameInProgress: false,
                dealerTurn: false,
                doubleDown: false
            };
            
            // Constantes
            const SUITS = ['♠', '♥', '♦', '♣'];
            const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            
            // Initialiser l'affichage
            updateStats();
            
            // Créer un jeu de cartes
            function createDeck() {
                const deck = [];
                for (const suit of SUITS) {
                    for (const value of VALUES) {
                        deck.push({
                            suit,
                            value,
                            isRed: suit === '♥' || suit === '♦'
                        });
                    }
                }
                return deck;
            }
            
            // Mélanger le jeu de cartes
            function shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                return deck;
            }
            
            // Tirer une carte du jeu
            function drawCard() {
                if (gameState.deck.length === 0) {
                    gameState.deck = shuffleDeck(createDeck());
                }
                return gameState.deck.pop();
            }
            
            // Déterminer la valeur d'une carte
            function getCardValue(card) {
                if (card.value === 'A') return 11;
                if (['J', 'Q', 'K'].includes(card.value)) return 10;
                return parseInt(card.value);
            }
            
            // Calculer le score d'une main
            function calculateScore(cards) {
                let score = 0;
                let aces = 0;
                
                for (const card of cards) {
                    const value = getCardValue(card);
                    if (card.value === 'A') aces++;
                    score += value;
                }
                
                // Considérer les As comme 1 si nécessaire
                while (score > 21 && aces > 0) {
                    score -= 10;
                    aces--;
                }
                
                return score;
            }
            
            // Créer un élément de carte
            function createCardElement(card, hidden = false) {
                const cardElement = document.createElement('div');
                cardElement.className = `blackjack-card${hidden ? ' hidden' : ''}`;
                
                if (!hidden) {
                    const valueTop = document.createElement('div');
                    valueTop.className = 'card-value';
                    valueTop.textContent = card.value;
                    
                    const suit = document.createElement('div');
                    suit.className = `card-suit ${card.isRed ? 'red' : 'black'}`;
                    suit.textContent = card.suit;
                    
                    const valueBottom = document.createElement('div');
                    valueBottom.className = 'card-value';
                    valueBottom.textContent = card.value;
                    valueBottom.style.transform = 'rotate(180deg)';
                    
                    cardElement.appendChild(valueTop);
                    cardElement.appendChild(suit);
                    cardElement.appendChild(valueBottom);
                }
                
                return cardElement;
            }
            
            // Ajouter une mise
            function addToBet(amount) {
                if (gameState.gameInProgress) return;
                
                let currentValue = parseInt(betInput.value) || 0;
                currentValue += amount;
                
                if (currentValue > gameState.balance) {
                    currentValue = gameState.balance;
                }
                
                betInput.value = currentValue;
            }
            
            // Effacer la mise
            function clearBet() {
                if (gameState.gameInProgress) return;
                betInput.value = 10;
            }
            
            // Démarrer une partie
            function startBlackjackGame() {
                const bet = parseInt(betInput.value) || 0;
                
                if (bet < 5) {
                    messageElement.textContent = 'La mise minimum est de 5€';
                    return;
                }
                
                if (bet > gameState.balance) {
                    messageElement.textContent = 'Mise trop élevée par rapport à votre solde';
                    return;
                }
                
                // Initialiser le jeu
                gameState.currentBet = bet;
                gameState.balance -= bet;
                gameState.gameInProgress = true;
                gameState.dealerTurn = false;
                gameState.doubleDown = false;
                gameState.deck = shuffleDeck(createDeck());
                gameState.dealerCards = [];
                gameState.playerCards = [];
                
                // Masquer le conteneur de mise
                betContainer.style.display = 'none';
                blackjackTable.style.display = 'block';
                
                // Distribution initiale
                dealerCardsContainer.innerHTML = '';
                playerCardsContainer.innerHTML = '';
                
                // Le croupier prend une carte visible et une cachée
                const dealerCard1 = drawCard();
                const dealerCard2 = drawCard();
                gameState.dealerCards = [dealerCard1, dealerCard2];
                dealerCardsContainer.appendChild(createCardElement(dealerCard1));
                dealerCardsContainer.appendChild(createCardElement(dealerCard2, true));
                
                // Le joueur prend deux cartes visibles
                const playerCard1 = drawCard();
                const playerCard2 = drawCard();
                gameState.playerCards = [playerCard1, playerCard2];
                playerCardsContainer.appendChild(createCardElement(playerCard1));
                playerCardsContainer.appendChild(createCardElement(playerCard2));
                
                // Mise à jour des scores
                gameState.dealerScore = getCardValue(dealerCard1); // On ne compte que la carte visible
                gameState.playerScore = calculateScore(gameState.playerCards);
                
                dealerScoreElement.textContent = gameState.dealerScore;
                playerScoreElement.textContent = gameState.playerScore;
                
                // Vérifier le blackjack
                if (gameState.playerScore === 21) {
                    dealerCardsContainer.innerHTML = '';
                    for (const card of gameState.dealerCards) {
                        dealerCardsContainer.appendChild(createCardElement(card));
                    }
                    gameState.dealerScore = calculateScore(gameState.dealerCards);
                    dealerScoreElement.textContent = gameState.dealerScore;
                    
                    if (gameState.dealerScore === 21) {
                        // Égalité
                        endGame('push');
                    } else {
                        // Blackjack
                        endGame('blackjack');
                    }
                    return;
                }
                
                // Activer les boutons
                hitBtn.disabled = false;
                standBtn.disabled = false;
                doubleBtn.disabled = gameState.balance < gameState.currentBet;
                
                // Ajouter les événements
                hitBtn.onclick = playerHit;
                standBtn.onclick = playerStand;
                doubleBtn.onclick = playerDouble;
                
                // Afficher le message
                messageElement.textContent = 'À vous de jouer! Tirez une carte ou restez.';
                
                // Mise à jour des statistiques
                updateStats();
            }
            
            // Le joueur tire une carte
            function playerHit() {
                if (!gameState.gameInProgress || gameState.dealerTurn) return;
                
                // Tirer une carte
                const card = drawCard();
                gameState.playerCards.push(card);
                playerCardsContainer.appendChild(createCardElement(card));
                
                // Mise à jour du score
                gameState.playerScore = calculateScore(gameState.playerCards);
                playerScoreElement.textContent = gameState.playerScore;
                
                // Vérifier si le joueur a dépassé 21
                if (gameState.playerScore > 21) {
                    endGame('bust');
                    return;
                }
                
                // Désactiver le bouton doubler
                doubleBtn.disabled = true;
                
                // Afficher le message
                messageElement.textContent = 'Tirez une carte ou restez.';
            }
            
            // Le joueur reste
            function playerStand() {
                if (!gameState.gameInProgress || gameState.dealerTurn) return;
                
                // Passer au tour du croupier
                dealerTurn();
            }
            
            // Le joueur double sa mise
            function playerDouble() {
                if (!gameState.gameInProgress || gameState.dealerTurn || gameState.doubleDown) return;
                
                // Vérifier si le joueur a assez d'argent
                if (gameState.balance < gameState.currentBet) {
                    messageElement.textContent = 'Vous n\'avez pas assez d\'argent pour doubler!';
                    return;
                }
                
                // Doubler la mise
                gameState.balance -= gameState.currentBet;
                gameState.currentBet *= 2;
                gameState.doubleDown = true;
                
                // Tirer une seule carte
                const card = drawCard();
                gameState.playerCards.push(card);
                playerCardsContainer.appendChild(createCardElement(card));
                
                // Mise à jour du score
                gameState.playerScore = calculateScore(gameState.playerCards);
                playerScoreElement.textContent = gameState.playerScore;
                
                // Vérifier si le joueur a dépassé 21
                if (gameState.playerScore > 21) {
                    endGame('bust');
                    return;
                }
                
                // Passer au tour du croupier
                dealerTurn();
                
                // Mise à jour des statistiques
                updateStats();
            }
            
            // Tour du croupier
            function dealerTurn() {
                gameState.dealerTurn = true;
                
                // Désactiver les boutons
                hitBtn.disabled = true;
                standBtn.disabled = true;
                doubleBtn.disabled = true;
                
                // Retourner la carte cachée
                dealerCardsContainer.innerHTML = '';
                for (const card of gameState.dealerCards) {
                    dealerCardsContainer.appendChild(createCardElement(card));
                }
                
                // Mise à jour du score
                gameState.dealerScore = calculateScore(gameState.dealerCards);
                dealerScoreElement.textContent = gameState.dealerScore;
                
                // Le croupier tire des cartes jusqu'à avoir 17 ou plus
                const dealerPlay = () => {
                    if (gameState.dealerScore < 17) {
                        const card = drawCard();
                        gameState.dealerCards.push(card);
                        dealerCardsContainer.appendChild(createCardElement(card));
                        
                        gameState.dealerScore = calculateScore(gameState.dealerCards);
                        dealerScoreElement.textContent = gameState.dealerScore;
                        
                        // Animation pour espacer les actions du croupier
                        setTimeout(dealerPlay, 600);
                    } else {
                        // Déterminer le résultat
                        if (gameState.dealerScore > 21) {
                            endGame('dealerBust');
                        } else if (gameState.dealerScore > gameState.playerScore) {
                            endGame('lose');
                        } else if (gameState.dealerScore < gameState.playerScore) {
                            endGame('win');
                        } else {
                            endGame('push');
                        }
                    }
                };
                
                // Animation
                setTimeout(dealerPlay, 600);
            }
            
            // Terminer la partie
            function endGame(result) {
                gameState.gameInProgress = false;
                gameState.gamesPlayed++;
                
                let winAmount = 0;
                let resultText = '';
                let resultClass = '';
                
                switch (result) {
                    case 'win':
                        winAmount = gameState.currentBet * 2;
                        resultText = 'VICTOIRE!';
                        resultClass = 'result-win';
                        gameState.gamesWon++;
                        break;
                    case 'blackjack':
                        winAmount = gameState.currentBet * 2.5;
                        resultText = 'BLACKJACK!';
                        resultClass = 'result-blackjack';
                        gameState.gamesWon++;
                        break;
                    case 'push':
                        winAmount = gameState.currentBet;
                        resultText = 'ÉGALITÉ';
                        resultClass = 'result-push';
                        break;
                    case 'dealerBust':
                        winAmount = gameState.currentBet * 2;
                        resultText = 'CROUPIER PERD!';
                        resultClass = 'result-win';
                        gameState.gamesWon++;
                        break;
                    case 'bust':
                        winAmount = 0;
                        resultText = 'PERDU!';
                        resultClass = 'result-lose';
                        break;
                    case 'lose':
                        winAmount = 0;
                        resultText = 'PERDU!';
                        resultClass = 'result-lose';
                        break;
                }
                
                // Mise à jour du solde
                gameState.balance += winAmount;
                
                // Afficher le résultat
                resultTitleElement.textContent = resultText;
                resultTitleElement.className = 'result-title ' + resultClass;
                
                const netGain = winAmount - gameState.currentBet;
                resultAmountElement.textContent = netGain >= 0 ? 
                    `+${netGain}€` :
                    `${netGain}€`;
                
                // Afficher l'écran de résultat
                resultElement.classList.add('visible');
                
                // Créer des confettis si le joueur gagne
                if (result === 'win' || result === 'blackjack' || result === 'dealerBust') {
                    createConfetti();
                }
                
                // Mettre à jour les statistiques
                updateStats();
                saveStats();
                
                // Le bouton pour rejouer
                playAgainBtn.onclick = resetGame;
                
                // Afficher le message
                if (result === 'blackjack') {
                    messageElement.textContent = 'Blackjack! Vous gagnez 3 pour 2.';
                } else if (result === 'push') {
                    messageElement.textContent = 'Égalité! Votre mise vous est rendue.';
                } else if (result === 'dealerBust') {
                    messageElement.textContent = 'Le croupier a dépassé 21! Vous gagnez.';
                } else if (result === 'bust') {
                    messageElement.textContent = 'Vous avez dépassé 21! Vous perdez.';
                } else if (result === 'win') {
                    messageElement.textContent = 'Vous battez le croupier! Vous gagnez.';
                } else if (result === 'lose') {
                    messageElement.textContent = 'Le croupier gagne avec un score plus élevé.';
                }
            }
             
             // Réinitialiser le jeu
             function resetGame() {
                 resultElement.classList.remove('visible');
                 blackjackTable.style.display = 'none';
                 betContainer.style.display = 'flex';
                 messageElement.textContent = 'Placez votre mise pour commencer une nouvelle partie.';
             }
             
             // Créer des confettis
             function createConfetti() {
                 const confettiContainer = document.querySelector('#blackjack-table');
                 const colors = ['#FF416C', '#FF4B2B', '#4CAF50', '#2196F3', '#FFC107', '#9C27B0'];
                 
                 for (let i = 0; i < 50; i++) {
                     const confetti = document.createElement('div');
                     confetti.className = 'confetti';
                     confetti.style.left = Math.random() * 100 + '%';
                     confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                     confetti.style.width = Math.random() * 8 + 5 + 'px';
                     confetti.style.height = Math.random() * 8 + 5 + 'px';
                     confetti.style.animationDuration = Math.random() * 3 + 2 + 's';
                     confettiContainer.appendChild(confetti);
                     
                     // Supprimer les confettis après l'animation
                     setTimeout(() => {
                         confetti.remove();
                     }, 5000);
                 }
             }
             
             // Mise à jour des statistiques
             function updateStats() {
                 balanceElement.textContent = `${gameState.balance}€`;
                 currentBetElement.textContent = `${gameState.currentBet}€`;
                 gamesPlayedElement.textContent = gameState.gamesPlayed;
                 gamesWonElement.textContent = gameState.gamesWon;
             }
             
             // Sauvegarder les statistiques
             function saveStats() {
                 localStorage.setItem('blackjackBalance', gameState.balance);
                 localStorage.setItem('blackjackGamesPlayed', gameState.gamesPlayed);
                 localStorage.setItem('blackjackGamesWon', gameState.gamesWon);
             }
             
             // Exposer les fonctions au scope global
             window.addToBet = addToBet;
             window.clearBet = clearBet;
             window.startBlackjackGame = startBlackjackGame;
        }

        // Jeu Sweet Match (style Candy Crush)
        function initSweetMatch() {
            // Éléments du DOM
            const board = document.getElementById('sweet-match-board');
            const scoreElement = document.getElementById('sweet-score');
            const bestScoreElement = document.getElementById('sweet-best-score');
            const levelElement = document.getElementById('sweet-level');
            const movesElement = document.getElementById('sweet-moves');
            const messageElement = document.getElementById('sweet-match-message');
            const progressBar = document.getElementById('sweet-progress-bar');
            const timeBar = document.getElementById('sweet-time-bar');
            const levelTargetElement = document.getElementById('sweet-level-target');
            const newGameBtn = document.getElementById('sweet-new-game-btn');
            const hintBtn = document.getElementById('sweet-hint-btn');
            
            // Configuration du jeu
            const BOARD_SIZE = 8;
            const CANDY_TYPES = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
            const CANDY_EMOJIS = {
                'red': '🍒',
                'blue': '🫐',
                'green': '🥝',
                'yellow': '🍋',
                'purple': '🍇',
                'orange': '🍊'
            };
            const MATCH_SCORE = {
                3: 30,
                4: 60,
                5: 100
            };
            
            // État du jeu
            const gameState = {
                board: [],
                selectedCell: null,
                score: 0,
                bestScore: localStorage.getItem('sweetMatchBestScore') ? parseInt(localStorage.getItem('sweetMatchBestScore')) : 0,
                level: 1,
                movesLeft: 15,
                isSwapping: false,
                isAnimating: false,
                isGameOver: false,
                targetScore: 1000,
                timeLeft: 100,
                timerInterval: null
            };
            
            // Initialiser l'affichage
            bestScoreElement.textContent = gameState.bestScore;
            levelTargetElement.textContent = gameState.targetScore;
            
            // Initialiser le jeu
            createBoard();
            newGameBtn.addEventListener('click', startNewGame);
            hintBtn.addEventListener('click', showHint);
            
            // Créer la grille de jeu
            function createBoard() {
                board.innerHTML = '';
                gameState.board = [];
                
                for (let row = 0; row < BOARD_SIZE; row++) {
                    const rowArray = [];
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'sweet-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.addEventListener('click', handleCellClick);
                        
                        // Générer un bonbon aléatoire qui ne crée pas de match initial
                        let candyType;
                        do {
                            candyType = getRandomCandyType();
                        } while (
                            (col >= 2 && 
                             rowArray[col-2] === candyType && 
                             rowArray[col-1] === candyType) ||
                            (row >= 2 && 
                             gameState.board[row-2] && 
                             gameState.board[row-1] && 
                             gameState.board[row-2][col] === candyType && 
                             gameState.board[row-1][col] === candyType)
                        );
                        
                        rowArray.push(candyType);
                        
                        const candy = createCandyElement(candyType);
                        cell.appendChild(candy);
                        board.appendChild(cell);
                    }
                    gameState.board.push(rowArray);
                }
                
                // Vérifier si des mouvements sont possibles
                if (!hasValidMoves()) {
                    resetBoard();
                }
            }
            
            // Créer un élément bonbon
            function createCandyElement(type) {
                const candy = document.createElement('div');
                candy.className = `sweet-candy sweet-candy-${type}`;
                candy.textContent = CANDY_EMOJIS[type];
                return candy;
            }
            
            // Obtenir un type de bonbon aléatoire
            function getRandomCandyType() {
                return CANDY_TYPES[Math.floor(Math.random() * CANDY_TYPES.length)];
            }
            
            // Gérer le clic sur une cellule
            function handleCellClick(event) {
                if (gameState.isAnimating || gameState.isGameOver) return;
                
                const cell = event.currentTarget;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // Si aucune cellule n'est sélectionnée, sélectionner celle-ci
                if (!gameState.selectedCell) {
                    selectCell(cell, row, col);
                } else {
                    // Si la même cellule est cliquée, la désélectionner
                    if (gameState.selectedCell.row === row && gameState.selectedCell.col === col) {
                        deselectCell();
                    } else {
                        // Vérifier si la cellule est adjacente
                        const rowDiff = Math.abs(gameState.selectedCell.row - row);
                        const colDiff = Math.abs(gameState.selectedCell.col - col);
                        
                        if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                            // Échanger les bonbons
                            swapCandies(gameState.selectedCell.row, gameState.selectedCell.col, row, col);
                        } else {
                            // Sélectionner la nouvelle cellule
                            deselectCell();
                            selectCell(cell, row, col);
                        }
                    }
                }
            }
            
            // Sélectionner une cellule
            function selectCell(cell, row, col) {
                gameState.selectedCell = { element: cell, row, col };
                cell.classList.add('selected');
            }
            
            // Désélectionner la cellule
            function deselectCell() {
                if (gameState.selectedCell) {
                    gameState.selectedCell.element.classList.remove('selected');
                    gameState.selectedCell = null;
                }
            }
            
            // Échanger deux bonbons
            function swapCandies(row1, col1, row2, col2) {
                if (gameState.isSwapping) return;
                
                gameState.isSwapping = true;
                gameState.isAnimating = true;
                
                // Échanger dans le tableau
                const temp = gameState.board[row1][col1];
                gameState.board[row1][col1] = gameState.board[row2][col2];
                gameState.board[row2][col2] = temp;
                
                // Animer l'échange
                const cell1 = getCellElement(row1, col1);
                const cell2 = getCellElement(row2, col2);
                
                cell1.classList.add('swapping');
                cell2.classList.add('swapping');
                
                // Échanger visuellement
                const candy1 = cell1.querySelector('.sweet-candy');
                const candy2 = cell2.querySelector('.sweet-candy');
                
                cell1.innerHTML = '';
                cell2.innerHTML = '';
                
                cell1.appendChild(candy2.cloneNode(true));
                cell2.appendChild(candy1.cloneNode(true));
                
                // Mettre à jour les classes
                updateCandyClasses();
                
                // Vérifier les correspondances après l'échange
                setTimeout(() => {
                    cell1.classList.remove('swapping');
                    cell2.classList.remove('swapping');
                    
                    const matches = findMatches();
                    
                    if (matches.length > 0) {
                        // Il y a des correspondances
                        removeMatches(matches);
                        updateMovesAndScore();
                    } else {
                        // Annuler l'échange si aucune correspondance
                        messageElement.textContent = "Pas de correspondance, essayez un autre mouvement!";
                        
                        // Remettre le tableau dans son état d'origine
                        gameState.board[row1][col1] = gameState.board[row2][col2];
                        gameState.board[row2][col2] = temp;
                        
                        // Animer le retour
                        cell1.classList.add('swapping');
                        cell2.classList.add('swapping');
                        
                        const candy1New = cell1.querySelector('.sweet-candy');
                        const candy2New = cell2.querySelector('.sweet-candy');
                        
                        cell1.innerHTML = '';
                        cell2.innerHTML = '';
                        
                        cell1.appendChild(candy2New.cloneNode(true));
                        cell2.appendChild(candy1New.cloneNode(true));
                        
                        updateCandyClasses();
                        
                        setTimeout(() => {
                            cell1.classList.remove('swapping');
                            cell2.classList.remove('swapping');
                            gameState.isSwapping = false;
                            gameState.isAnimating = false;
                        }, 300);
                    }
                    
                    deselectCell();
                }, 300);
            }
            
            // Obtenir l'élément cellule par coordonnées
            function getCellElement(row, col) {
                return document.querySelector(`.sweet-cell[data-row="${row}"][data-col="${col}"]`);
            }
            
            // Mettre à jour les classes des bonbons pour correspondre au tableau
            function updateCandyClasses() {
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const cell = getCellElement(row, col);
                        const candy = cell.querySelector('.sweet-candy');
                        if (candy) {
                            const type = gameState.board[row][col];
                            candy.className = `sweet-candy sweet-candy-${type}`;
                            candy.textContent = CANDY_EMOJIS[type];
                        }
                    }
                }
            }
            
            // Trouver les correspondances sur le plateau
            function findMatches() {
                const matches = [];
                
                // Vérifier les correspondances horizontales
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE - 2; col++) {
                        const type = gameState.board[row][col];
                        if (type === gameState.board[row][col+1] && type === gameState.board[row][col+2]) {
                            // Trouver la longueur complète du match
                            let matchLength = 3;
                            while (col + matchLength < BOARD_SIZE && gameState.board[row][col + matchLength] === type) {
                                matchLength++;
                            }
                            
                            const match = {
                                type: 'horizontal',
                                row: row,
                                col: col,
                                length: matchLength,
                                candyType: type
                            };
                            matches.push(match);
                            
                            // Avancer pour éviter de compter plusieurs fois le même match
                            col += matchLength - 1;
                        }
                    }
                }
                
                // Vérifier les correspondances verticales
                for (let col = 0; col < BOARD_SIZE; col++) {
                    for (let row = 0; row < BOARD_SIZE - 2; row++) {
                        const type = gameState.board[row][col];
                        if (type === gameState.board[row+1][col] && type === gameState.board[row+2][col]) {
                            // Trouver la longueur complète du match
                            let matchLength = 3;
                            while (row + matchLength < BOARD_SIZE && gameState.board[row + matchLength][col] === type) {
                                matchLength++;
                            }
                            
                            const match = {
                                type: 'vertical',
                                row: row,
                                col: col,
                                length: matchLength,
                                candyType: type
                            };
                            matches.push(match);
                            
                            // Avancer pour éviter de compter plusieurs fois le même match
                            row += matchLength - 1;
                        }
                    }
                }
                
                return matches;
            }
            
            // Supprimer les correspondances et faire tomber les bonbons
            function removeMatches(matches) {
                const cellsToRemove = new Set();
                
                // Marquer les cellules à supprimer
                matches.forEach(match => {
                    if (match.type === 'horizontal') {
                        for (let i = 0; i < match.length; i++) {
                            cellsToRemove.add(`${match.row},${match.col + i}`);
                        }
                    } else {
                        for (let i = 0; i < match.length; i++) {
                            cellsToRemove.add(`${match.row + i},${match.col}`);
                        }
                    }
                    
                    // Ajouter des points selon la longueur de la correspondance
                    gameState.score += MATCH_SCORE[Math.min(match.length, 5)] * (gameState.level * 0.5 + 1);
                });
                
                // Animer la suppression
                cellsToRemove.forEach(key => {
                    const [row, col] = key.split(',').map(Number);
                    const cell = getCellElement(row, col);
                    cell.classList.add('matched');
                    
                    // Ajouter une animation d'explosion
                    const explosion = document.createElement('div');
                    explosion.className = 'sweet-explosion';
                    explosion.style.backgroundColor = `var(--${gameState.board[row][col]})`;
                    cell.appendChild(explosion);
                    
                    setTimeout(() => {
                        explosion.remove();
                    }, 500);
                });
                
                // Attendre que l'animation se termine
                setTimeout(() => {
                    // Supprimer les bonbons correspondants
                    cellsToRemove.forEach(key => {
                        const [row, col] = key.split(',').map(Number);
                        gameState.board[row][col] = null;
                    });
                    
                    // Faire tomber les bonbons
                    dropCandies();
                    
                    // Remplir avec de nouveaux bonbons
                    fillEmptyCells();
                    
                    // Mettre à jour l'affichage
                    updateCandyClasses();
                    
                    // Vérifier s'il y a de nouvelles correspondances
                    setTimeout(() => {
                        const newMatches = findMatches();
                        if (newMatches.length > 0) {
                            removeMatches(newMatches);
                        } else {
                            // Vérifier si des mouvements sont possibles
                            if (!hasValidMoves()) {
                                resetBoard();
                            }
                            
                            // Fin de l'animation
                            gameState.isSwapping = false;
                            gameState.isAnimating = false;
                            
                            // Vérifier si le niveau est terminé
                            checkLevelEnd();
                        }
                    }, 500);
                }, 500);
                
                // Mettre à jour le score affiché
                scoreElement.textContent = Math.floor(gameState.score);
                
                // Mettre à jour la barre de progression
                const progress = Math.min(100, (gameState.score / gameState.targetScore) * 100);
                progressBar.style.width = `${progress}%`;
            }
            
            // Faire tomber les bonbons après une correspondance
            function dropCandies() {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    // Compter combien de cases null il y a dans chaque colonne
                    let nullCount = 0;
                    
                    // Parcourir de bas en haut
                    for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                        if (gameState.board[row][col] === null) {
                            nullCount++;
                        } else if (nullCount > 0) {
                            // Déplacer le bonbon vers le bas
                            gameState.board[row + nullCount][col] = gameState.board[row][col];
                            gameState.board[row][col] = null;
                            
                            // Animer la chute
                            const sourceCell = getCellElement(row, col);
                            const targetCell = getCellElement(row + nullCount, col);
                            
                            const candy = sourceCell.querySelector('.sweet-candy');
                            sourceCell.innerHTML = '';
                            targetCell.innerHTML = '';
                            targetCell.appendChild(candy);
                        }
                    }
                }
            }
            
            // Remplir les cellules vides avec de nouveaux bonbons
            function fillEmptyCells() {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    for (let row = 0; row < BOARD_SIZE; row++) {
                        if (gameState.board[row][col] === null) {
                            // Générer un nouveau bonbon
                            const newType = getRandomCandyType();
                            gameState.board[row][col] = newType;
                            
                            // Ajouter visuellement
                            const cell = getCellElement(row, col);
                            cell.classList.remove('matched');
                            
                            const candy = createCandyElement(newType);
                            cell.innerHTML = '';
                            cell.appendChild(candy);
                        }
                    }
                }
            }
            
            // Mettre à jour les mouvements et le score
            function updateMovesAndScore() {
                gameState.movesLeft--;
                movesElement.textContent = gameState.movesLeft;
                
                // Mise à jour du meilleur score
                if (gameState.score > gameState.bestScore) {
                    gameState.bestScore = Math.floor(gameState.score);
                    bestScoreElement.textContent = gameState.bestScore;
                    localStorage.setItem('sweetMatchBestScore', gameState.bestScore);
                }
            }
            
            // Vérifier si le niveau est terminé
            function checkLevelEnd() {
                if (gameState.score >= gameState.targetScore) {
                    // Niveau réussi
                    messageElement.textContent = "Niveau réussi! Passage au niveau suivant...";
                    gameState.level++;
                    levelElement.textContent = gameState.level;
                    
                    // Augmenter la difficulté
                    gameState.targetScore = Math.floor(gameState.targetScore * 1.5);
                    levelTargetElement.textContent = gameState.targetScore;
                    
                    // Réinitialiser les mouvements
                    gameState.movesLeft = 15 + Math.floor(gameState.level / 2);
                    movesElement.textContent = gameState.movesLeft;
                    
                    // Réinitialiser la progression
                    progressBar.style.width = "0%";
                    
                    // Démarrer un nouveau niveau après un délai
                    setTimeout(() => {
                        resetBoard();
                    }, 2000);
                    
                } else if (gameState.movesLeft <= 0) {
                    // Partie terminée
                    gameState.isGameOver = true;
                    messageElement.textContent = "Partie terminée! Plus de mouvements.";
                }
            }
            
            // Vérifier s'il y a des mouvements valides sur le plateau
            function hasValidMoves() {
                // Vérifier horizontalement
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE - 1; col++) {
                        // Échanger avec le bonbon à droite
                        const temp = gameState.board[row][col];
                        gameState.board[row][col] = gameState.board[row][col + 1];
                        gameState.board[row][col + 1] = temp;
                        
                        // Vérifier s'il y a des correspondances
                        const matches = findMatches();
                        
                        // Remettre les bonbons à leur place
                        gameState.board[row][col + 1] = gameState.board[row][col];
                        gameState.board[row][col] = temp;
                        
                        if (matches.length > 0) {
                            return true;
                        }
                    }
                }
                
                // Vérifier verticalement
                for (let col = 0; col < BOARD_SIZE; col++) {
                    for (let row = 0; row < BOARD_SIZE - 1; row++) {
                        // Échanger avec le bonbon en dessous
                        const temp = gameState.board[row][col];
                        gameState.board[row][col] = gameState.board[row + 1][col];
                        gameState.board[row + 1][col] = temp;
                        
                        // Vérifier s'il y a des correspondances
                        const matches = findMatches();
                        
                        // Remettre les bonbons à leur place
                        gameState.board[row + 1][col] = gameState.board[row][col];
                        gameState.board[row][col] = temp;
                        
                        if (matches.length > 0) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // Réinitialiser le plateau
            function resetBoard() {
                messageElement.textContent = "Réorganisation du plateau...";
                createBoard();
                gameState.isGameOver = false;
                gameState.isSwapping = false;
                gameState.isAnimating = false;
            }
            
            // Démarrer une nouvelle partie
            function startNewGame() {
                gameState.score = 0;
                gameState.level = 1;
                gameState.targetScore = 1000;
                gameState.movesLeft = 15;
                gameState.isGameOver = false;
                
                scoreElement.textContent = gameState.score;
                levelElement.textContent = gameState.level;
                movesElement.textContent = gameState.movesLeft;
                levelTargetElement.textContent = gameState.targetScore;
                
                progressBar.style.width = "0%";
                messageElement.textContent = "Alignez 3 bonbons ou plus pour marquer des points!";
                
                resetBoard();
            }
            
            // Afficher un indice
            function showHint() {
                if (gameState.isAnimating || gameState.isGameOver) return;
                
                // Chercher un mouvement valide
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE - 1; col++) {
                        // Tester l'échange horizontal
                        const temp = gameState.board[row][col];
                        gameState.board[row][col] = gameState.board[row][col + 1];
                        gameState.board[row][col + 1] = temp;
                        
                        const matches = findMatches();
                        
                        // Remettre dans l'état d'origine
                        gameState.board[row][col] = gameState.board[row][col + 1];
                        gameState.board[row][col + 1] = temp;
                        
                        if (matches.length > 0) {
                            // Trouver un mouvement valide - montrer l'indice
                            const cell1 = getCellElement(row, col);
                            const cell2 = getCellElement(row, col + 1);
                            
                            highlightCells([cell1, cell2]);
                            return;
                        }
                    }
                }
                
                // Vérifier verticalement si aucun mouvement horizontal n'a été trouvé
                for (let col = 0; col < BOARD_SIZE; col++) {
                    for (let row = 0; row < BOARD_SIZE - 1; row++) {
                        // Tester l'échange vertical
                        const temp = gameState.board[row][col];
                        gameState.board[row][col] = gameState.board[row + 1][col];
                        gameState.board[row + 1][col] = temp;
                        
                        const matches = findMatches();
                        
                        // Remettre dans l'état d'origine
                        gameState.board[row][col] = gameState.board[row + 1][col];
                        gameState.board[row + 1][col] = temp;
                        
                        if (matches.length > 0) {
                            // Trouver un mouvement valide - montrer l'indice
                            const cell1 = getCellElement(row, col);
                            const cell2 = getCellElement(row + 1, col);
                            
                            highlightCells([cell1, cell2]);
                            return;
                        }
                    }
                }
                
                // Aucun mouvement valide
                messageElement.textContent = "Aucun mouvement valide trouvé! Réorganisation du plateau...";
                resetBoard();
            }
            
            // Mettre en surbrillance des cellules pour un indice
            function highlightCells(cells) {
                cells.forEach(cell => {
                    cell.classList.add('selected');
                });
                
                setTimeout(() => {
                    cells.forEach(cell => {
                        cell.classList.remove('selected');
                    });
                }, 1000);
                
                messageElement.textContent = "Indice : essayez ces bonbons !";
            }
        }

        // Jeu de Pong
        function initPong() {
            // Éléments du DOM
            const gameContainer = document.getElementById('pong-game-container');
            const playerScoreElement = document.getElementById('pong-player-score');
            const aiScoreElement = document.getElementById('pong-ai-score');
            const messageElement = document.getElementById('pong-message');
            const startBtn = document.getElementById('pong-start-btn');
            const resetBtn = document.getElementById('pong-reset-btn');
            const pauseBtn = document.getElementById('pong-pause-btn');
            const difficultySelect = document.getElementById('pong-difficulty-select');
            
            // Configuration du jeu
            const GAME_WIDTH = 600;
            const GAME_HEIGHT = 400;
            const PADDLE_WIDTH = 10;
            const PADDLE_HEIGHT = 80;
            const BALL_SIZE = 15;
            const PADDLE_SPEED = 8;
            const WINNING_SCORE = 10;
            
            // État du jeu
            const gameState = {
                playerScore: 0,
                aiScore: 0,
                paused: false,
                gameStarted: false,
                gameOver: false,
                difficultyLevel: 'medium',
                animationFrameId: null,
                lastTime: 0,
                countdownValue: 3,
                countdownTimer: null,
                keyStates: {
                    ArrowUp: false,
                    ArrowDown: false
                }
            };
            
            // Objets du jeu
            const player = {
                x: 20,
                y: GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2,
                width: PADDLE_WIDTH,
                height: PADDLE_HEIGHT,
                speed: PADDLE_SPEED,
                element: null
            };
            
            const ai = {
                x: GAME_WIDTH - 20 - PADDLE_WIDTH,
                y: GAME_HEIGHT / 2 - PADDLE_HEIGHT / 2,
                width: PADDLE_WIDTH,
                height: PADDLE_HEIGHT,
                speed: 0, // Sera défini en fonction de la difficulté
                element: null
            };
            
            const ball = {
                x: GAME_WIDTH / 2 - BALL_SIZE / 2,
                y: GAME_HEIGHT / 2 - BALL_SIZE / 2,
                width: BALL_SIZE,
                height: BALL_SIZE,
                speedX: 0,
                speedY: 0,
                element: null
            };
            
            // Initialiser le jeu
            initializeGame();
            setupEventListeners();
            
            // Initialiser les éléments du jeu
            function initializeGame() {
                // Configurer le conteneur de jeu
                gameContainer.style.width = GAME_WIDTH + 'px';
                gameContainer.style.height = GAME_HEIGHT + 'px';
                gameContainer.style.position = 'relative';
                gameContainer.innerHTML = '';
                
                // Créer les raquettes et la balle
                createGameElements();
                
                // Réinitialiser les scores
                resetScores();
                
                // Définir la difficulté
                setDifficulty(difficultySelect.value);
                
                // Mettre à jour l'affichage
                updateGameDisplay();
            }
            
            // Créer les éléments du jeu
            function createGameElements() {
                // Créer la raquette du joueur
                player.element = document.createElement('div');
                player.element.className = 'pong-paddle left';
                player.element.style.height = player.height + 'px';
                player.element.style.width = player.width + 'px';
                player.element.style.top = player.y + 'px';
                player.element.style.left = player.x + 'px';
                gameContainer.appendChild(player.element);
                
                // Créer la raquette de l'IA
                ai.element = document.createElement('div');
                ai.element.className = 'pong-paddle right';
                ai.element.style.height = ai.height + 'px';
                ai.element.style.width = ai.width + 'px';
                ai.element.style.top = ai.y + 'px';
                ai.element.style.right = (GAME_WIDTH - ai.x - ai.width) + 'px';
                gameContainer.appendChild(ai.element);
                
                // Créer la balle
                ball.element = document.createElement('div');
                ball.element.className = 'pong-ball';
                ball.element.style.width = ball.width + 'px';
                ball.element.style.height = ball.height + 'px';
                ball.element.style.top = ball.y + 'px';
                ball.element.style.left = ball.x + 'px';
                gameContainer.appendChild(ball.element);
                
                // Créer l'élément de compte à rebours
                const countdown = document.createElement('div');
                countdown.id = 'pong-countdown';
                countdown.className = 'pong-countdown';
                countdown.style.display = 'none';
                gameContainer.appendChild(countdown);
            }
            
            // Configurer les écouteurs d'événements
            function setupEventListeners() {
                // Contrôles clavier
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                
                // Contrôle à la souris
                gameContainer.addEventListener('mousemove', handleMouseMove);
                
                // Boutons de contrôle
                startBtn.addEventListener('click', startGame);
                resetBtn.addEventListener('click', resetGame);
                pauseBtn.addEventListener('click', togglePause);
                
                // Sélecteur de difficulté
                difficultySelect.addEventListener('change', function() {
                    setDifficulty(this.value);
                });
            }
            
            // Gérer les événements clavier
            function handleKeyDown(e) {
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    gameState.keyStates[e.key] = true;
                }
            }
            
            function handleKeyUp(e) {
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    gameState.keyStates[e.key] = false;
                }
            }
            
            // Gérer les mouvements de la souris
            function handleMouseMove(e) {
                if (!gameState.gameStarted || gameState.paused) return;
                
                const containerRect = gameContainer.getBoundingClientRect();
                const relativeY = e.clientY - containerRect.top;
                
                // Limiter la position de la raquette à l'intérieur du conteneur
                player.y = Math.max(0, Math.min(GAME_HEIGHT - player.height, relativeY - player.height / 2));
                updatePaddlePosition(player);
            }
            
            // Démarrer le jeu
            function startGame() {
                if (gameState.gameStarted || gameState.countdownTimer) return;
                
                // Réinitialiser la position de la balle
                resetBallPosition();
                
                // Afficher le compte à rebours
                const countdownElement = document.getElementById('pong-countdown');
                countdownElement.style.display = 'block';
                gameState.countdownValue = 3;
                countdownElement.textContent = gameState.countdownValue;
                
                // Démarrer le compte à rebours
                gameState.countdownTimer = setInterval(() => {
                    gameState.countdownValue--;
                    
                    if (gameState.countdownValue > 0) {
                        countdownElement.textContent = gameState.countdownValue;
                    } else {
                        clearInterval(gameState.countdownTimer);
                        gameState.countdownTimer = null;
                        countdownElement.style.display = 'none';
                        
                        // Commencer le jeu après le compte à rebours
                        gameState.gameStarted = true;
                        gameState.paused = false;
                        gameState.gameOver = false;
                        
                        // Donner une vitesse initiale à la balle
                        setInitialBallSpeed();
                        
                        // Démarrer la boucle de jeu
                        if (!gameState.animationFrameId) {
                            gameState.lastTime = performance.now();
                            gameState.animationFrameId = requestAnimationFrame(gameLoop);
                        }
                        
                        messageElement.textContent = "C'est parti!";
                    }
                }, 1000);
            }
            
            // Réinitialiser le jeu
            function resetGame() {
                // Arrêter le jeu en cours
                cancelAnimationFrame(gameState.animationFrameId);
                gameState.animationFrameId = null;
                
                // Arrêter le compte à rebours s'il est en cours
                if (gameState.countdownTimer) {
                    clearInterval(gameState.countdownTimer);
                    gameState.countdownTimer = null;
                    document.getElementById('pong-countdown').style.display = 'none';
                }
                
                // Réinitialiser l'état du jeu
                gameState.gameStarted = false;
                gameState.paused = false;
                gameState.gameOver = false;
                
                // Réinitialiser les scores
                resetScores();
                
                // Réinitialiser les positions
                player.y = GAME_HEIGHT / 2 - player.height / 2;
                ai.y = GAME_HEIGHT / 2 - ai.height / 2;
                resetBallPosition();
                
                // Mettre à jour l'affichage
                updateGameDisplay();
                
                messageElement.textContent = "Jeu réinitialisé. Appuyez sur Commencer pour jouer.";
            }
            
            // Mettre le jeu en pause
            function togglePause() {
                if (!gameState.gameStarted || gameState.gameOver) return;
                
                gameState.paused = !gameState.paused;
                
                if (gameState.paused) {
                    cancelAnimationFrame(gameState.animationFrameId);
                    gameState.animationFrameId = null;
                    messageElement.textContent = "Jeu en pause";
                } else {
                    gameState.lastTime = performance.now();
                    gameState.animationFrameId = requestAnimationFrame(gameLoop);
                    messageElement.textContent = "Jeu repris";
                }
            }
            
            // Définir la difficulté
            function setDifficulty(level) {
                gameState.difficultyLevel = level;
                
                switch (level) {
                    case 'easy':
                        ai.speed = PADDLE_SPEED * 0.6;
                        break;
                    case 'medium':
                        ai.speed = PADDLE_SPEED * 0.8;
                        break;
                    case 'hard':
                        ai.speed = PADDLE_SPEED * 1.1;
                        break;
                }
                
                messageElement.textContent = `Difficulté définie sur ${level}`;
            }
            
            // Réinitialiser les scores
            function resetScores() {
                gameState.playerScore = 0;
                gameState.aiScore = 0;
                playerScoreElement.textContent = gameState.playerScore;
                aiScoreElement.textContent = gameState.aiScore;
            }
            
            // Réinitialiser la position de la balle
            function resetBallPosition() {
                ball.x = GAME_WIDTH / 2 - ball.width / 2;
                ball.y = GAME_HEIGHT / 2 - ball.height / 2;
                ball.speedX = 0;
                ball.speedY = 0;
                updateBallPosition();
            }
            
            // Donner une vitesse initiale à la balle
            function setInitialBallSpeed() {
                // Direction aléatoire (gauche ou droite)
                const direction = Math.random() > 0.5 ? 1 : -1;
                
                // Vitesse de base selon la difficulté
                let baseSpeed = 5;
                if (gameState.difficultyLevel === 'easy') {
                    baseSpeed = 4;
                } else if (gameState.difficultyLevel === 'hard') {
                    baseSpeed = 6;
                }
                
                ball.speedX = direction * baseSpeed;
                
                // Angle légèrement aléatoire pour la direction Y
                ball.speedY = (Math.random() * 2 - 1) * 3;
            }
            
            // Mettre à jour la position de la raquette
            function updatePaddlePosition(paddle) {
                paddle.element.style.top = paddle.y + 'px';
            }
            
            // Mettre à jour la position de la balle
            function updateBallPosition() {
                ball.element.style.top = ball.y + 'px';
                ball.element.style.left = ball.x + 'px';
            }
            
            // Mettre à jour l'affichage du jeu
            function updateGameDisplay() {
                updatePaddlePosition(player);
                updatePaddlePosition(ai);
                updateBallPosition();
            }
            
            // Vérifier et gérer les collisions
            function checkCollisions() {
                // Collision avec les bords haut/bas
                if (ball.y <= 0 || ball.y + ball.height >= GAME_HEIGHT) {
                    ball.speedY = -ball.speedY;
                    
                    // Ajuster la position pour éviter que la balle ne reste coincée
                    if (ball.y <= 0) {
                        ball.y = 0;
                    } else {
                        ball.y = GAME_HEIGHT - ball.height;
                    }
                }
                
                // Collision avec la raquette du joueur
                if (
                    ball.x <= player.x + player.width &&
                    ball.x + ball.width >= player.x &&
                    ball.y + ball.height >= player.y &&
                    ball.y <= player.y + player.height
                ) {
                    // Rebondir la balle avec un angle basé sur l'endroit où elle frappe la raquette
                    const hitPosition = (ball.y + ball.height / 2) - (player.y + player.height / 2);
                    const normalizedHitPosition = hitPosition / (player.height / 2);
                    
                    // Ajuster la direction et la vitesse
                    ball.speedX = -ball.speedX * 1.05; // Légère accélération à chaque rebond
                    ball.speedY = normalizedHitPosition * 5;
                    
                    // Déplacer la balle hors de la collision
                    ball.x = player.x + player.width;
                }
                
                // Collision avec la raquette de l'IA
                if (
                    ball.x + ball.width >= ai.x &&
                    ball.x <= ai.x + ai.width &&
                    ball.y + ball.height >= ai.y &&
                    ball.y <= ai.y + ai.height
                ) {
                    // Rebondir la balle avec un angle basé sur l'endroit où elle frappe la raquette
                    const hitPosition = (ball.y + ball.height / 2) - (ai.y + ai.height / 2);
                    const normalizedHitPosition = hitPosition / (ai.height / 2);
                    
                    // Ajuster la direction et la vitesse
                    ball.speedX = -ball.speedX * 1.05; // Légère accélération à chaque rebond
                    ball.speedY = normalizedHitPosition * 5;
                    
                    // Déplacer la balle hors de la collision
                    ball.x = ai.x - ball.width;
                }
                
                // La balle sort du côté gauche (point pour l'IA)
                if (ball.x + ball.width < 0) {
                    scorePoint('ai');
                }
                
                // La balle sort du côté droit (point pour le joueur)
                if (ball.x > GAME_WIDTH) {
                    scorePoint('player');
                }
            }
            
            // Marquer un point
            function scorePoint(scorer) {
                if (scorer === 'player') {
                    gameState.playerScore++;
                    playerScoreElement.textContent = gameState.playerScore;
                    messageElement.textContent = "Vous avez marqué un point!";
                } else {
                    gameState.aiScore++;
                    aiScoreElement.textContent = gameState.aiScore;
                    messageElement.textContent = "L'IA a marqué un point!";
                }
                
                // Vérifier si la partie est gagnée
                if (gameState.playerScore >= WINNING_SCORE || gameState.aiScore >= WINNING_SCORE) {
                    gameOver();
                } else {
                    // Réinitialiser la balle pour le point suivant
                    resetBallPosition();
                    
                    // Relancer la balle après un court délai
                    gameState.gameStarted = false;
                    setTimeout(() => {
                        if (!gameState.gameOver) {
                            gameState.gameStarted = true;
                            setInitialBallSpeed();
                        }
                    }, 1000);
                }
            }
            
            // Fin de partie
            function gameOver() {
                gameState.gameOver = true;
                gameState.gameStarted = false;
                
                cancelAnimationFrame(gameState.animationFrameId);
                gameState.animationFrameId = null;
                
                if (gameState.playerScore >= WINNING_SCORE) {
                    messageElement.textContent = "Félicitations! Vous avez gagné la partie!";
                } else {
                    messageElement.textContent = "L'IA a gagné la partie. Réessayez!";
                }
            }
            
            // Mettre à jour la position de l'IA
            function updateAI(deltaTime) {
                // L'IA suit la balle, mais avec un peu de retard et d'imprécision
                const targetY = ball.y + ball.height / 2 - ai.height / 2;
                
                // Ajouter une imprécision basée sur la difficulté
                let aiError = 0;
                
                if (gameState.difficultyLevel === 'easy') {
                    aiError = (Math.random() - 0.5) * 50;
                } else if (gameState.difficultyLevel === 'medium') {
                    aiError = (Math.random() - 0.5) * 30;
                } else {
                    aiError = (Math.random() - 0.5) * 10;
                }
                
                const aiTarget = targetY + aiError;
                
                // Déplacer la raquette de l'IA vers la cible
                if (ai.y < aiTarget) {
                    ai.y += ai.speed * deltaTime;
                } else if (ai.y > aiTarget) {
                    ai.y -= ai.speed * deltaTime;
                }
                
                // S'assurer que l'IA reste dans les limites
                ai.y = Math.max(0, Math.min(GAME_HEIGHT - ai.height, ai.y));
                
                updatePaddlePosition(ai);
            }
            
            // Boucle principale du jeu
            function gameLoop(timestamp) {
                // Calculer le temps écoulé
                const deltaTime = (timestamp - gameState.lastTime) / 16; // Normaliser à environ 60 FPS
                gameState.lastTime = timestamp;
                
                if (gameState.gameStarted && !gameState.paused && !gameState.gameOver) {
                    // Déplacer le joueur en fonction des touches pressées
                    if (gameState.keyStates.ArrowUp) {
                        player.y -= player.speed * deltaTime;
                    }
                    if (gameState.keyStates.ArrowDown) {
                        player.y += player.speed * deltaTime;
                    }
                    
                    // S'assurer que le joueur reste dans les limites
                    player.y = Math.max(0, Math.min(GAME_HEIGHT - player.height, player.y));
                    updatePaddlePosition(player);
                    
                    // Mettre à jour la position de l'IA
                    updateAI(deltaTime);
                    
                    // Déplacer la balle
                    ball.x += ball.speedX * deltaTime;
                    ball.y += ball.speedY * deltaTime;
                    updateBallPosition();
                    
                    // Vérifier les collisions
                    checkCollisions();
                }
                
                // Continuer la boucle de jeu
                gameState.animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            // Nettoyer les ressources lorsque le jeu est fermé
            function cleanup() {
                cancelAnimationFrame(gameState.animationFrameId);
                
                if (gameState.countdownTimer) {
                    clearInterval(gameState.countdownTimer);
                }
                
                window.removeEventListener('keydown', handleKeyDown);
                window.removeEventListener('keyup', handleKeyUp);
                gameContainer.removeEventListener('mousemove', handleMouseMove);
            }
            
            // Exposer la fonction de nettoyage au niveau global
            window.cleanupPong = cleanup;
        }
    </script>
</body>
</html>